/*  MOCK - Multiobjective Clustering with Automatic K-Determination
    Copyright (C) 2004 David Corne, Joshua Knowles and Julia Handl
    Email: Julia.Handl@gmx.de

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*/


/* PESA-II with external archiving using epsilon-approximate / epsilon-Pareto methods.
   The epsilon-approximate ones have an adaptive epsilon.
   Originally the adaptive epsilon can only increase -- this is function eps_approx()
   Later versions include being able to decrease epsilon too -- function eps_diminish()

Joshua Knowles, 24/10/2002

*/

/* 

PESA-II by David Corne

USAGE 

pesa  IP  EP  L  A  O  GEN  CR  CT  MR  MT  P  FUN  G  S SEL

IP - internal pop
EP - max size of external pop
(IP and EP mean just what they mean in SPEA)
L - number of genes
A - number of alleles per gene -- e.g. 2 = binary
O - number of objectives
GEN - number of generations. Number of evaluations will be GEN*IP
      (one generation means generating IP children and evaluating them)
CR - crossover rate  - proportion of new children generated by crossover
CT - crossover type  - 0 = 1pt, 1 = uniform
MR - mutation rate  - proportion of genes per genome which are mutated.
MT = mutation type -   0 = `new allele': when a gene is slated for mutation,
                       it will get a different allele.
                       1 = `random allele': ... it will get any allele,
                       so maybe the same one. So use 0 for flip.

     To understand CR and MR in context, each child-generation event is:
        
        - select a couple of parents, p1 and p2
        - with probability CR, let c result from p1 crossed with p2,
          otherwise just let c be parent 1.
        - mutate c (changing MR of it)

       so, a child either comes fromm crossover + mutate, or just mutate.

P = 100; ignore it, just make sure it's 100.
FUN = your function name
G = grid size; the number of divisions per dimension. Eg, if G=5, and
O=3, the objective space will be chopped into 125 cubes.          
S = rand seed.
SEL = selection method. 1 for binary tournament based on crowding,
      2 for binary tournament based on boxes.
e.g.:

pesa 10 100 20 20 2 10000 0.7 1 0.05 0 100 F5 10 777 1

To stick in your own function, 

 go to HERE1 to see the quick and dirty way of having evaluate()
call it.

 then write the function and stick it in somewhere. Eg:


int myfun(C *c)
{

  c->g  is the genome, an integer array 
    the function needn't return anything, it just has to stuff
    the objective values into c->o. E.G., here is f5 

    c->o[0] = gsize-1;
    c->o[1] = gsize-1;

    for (i = 0; i < gsize-1; i++)
    {
            if(c->g[i+1]==c->g[i]+1)
               c->o[0]--;

          if(c->g[i+1]==c->g[i]-1)
                c->o[1]--;
        }
}

 you can then maybe stick some problem specific
initialisation in the area of HERE2

*/




#include "pesa2.h"

#include "kmeans.h"
#include "gaclust.h"
#include <stdio.h>
#include <stdlib.h>
#include "math.h"
#define DEBUG 0
#define MAX_OBJ 5
#include "epsilon.h"
#include "string.h"
#include <iostream>
#include <fstream>
#include "databin.h"
#include "conf.h"
#include "evaluation.h"
#include <iomanip>
#include "random.h"
#include <time.h>

using namespace std;


FILE *fp;

extern double sqrt(double);
extern double pow(double,double);
extern conf * par;
extern databin<USED_DATA_TYPE> * bin;
bool printflag = false;
int it = 0;
char * dataname;
int run = 0;
int setting;


C *ip;
C *ep;
C *mp;

int prflag, prflag2, epindex, nbits, rflag, prindex;
int ipsize, epsize, grid, gsize, nalleles, iterations, nobjs, cross_type, ncents;
char fun[20];
long seed;


double *davemax, *davemin;

int *boxcount;
int *occboxes;
int noccboxes;

int selmeth;
int MINMAX=0;

double cross_rate, mute_rate;
int rgmutate;
int curepsize;


/* JK's variables for archiving */
double *jmin, *jmax;
double *epsi;
double *myvector;
int *julias_kill;
int *timestamps;
int max_arc=200;
int corr;
int num_vecs=0;
int STEP = 4;

int depth=3;
int grid_pop[5000];
int loc[2000];
int crowded_region[20];
int uev[500];  // uniquely extremal vectors as a binary list
int num_cr;
int iter=0;
int MAXNO = 20;
int MINNO = 1;
int L = 20;
int globalclust, globaldim, globalsize;
char * filename;

double *cc;
double psep;

C *select1();
C *select2();


double difference(double * solution, double *control, int curepsize);
double median(double *, int);
double cut(double * solution, double * dir, double * target, int dim, double * control, int curepsize);
double attainmentcut(double * solution, double *control, int curepsize, int dim);
int int_lt (const void *a, const void *b);
int int_lt1 (const void *a, const void *b);
int int_lt2 (const void *a, const void *b);

bool lt (const void *a, const void *b);
void julias_srandom(unsigned);
long int rrandom();
int myrand(int);
int *relabel;
int *altg;
int jobnbr;

void eps_approx(double *vp, double *newpoint, int ts, int k, double *epsi, int *num_vecs);
int eps_Pareto(double *vp, double *newpoint, int k, double *epsi, int *num_vecs);
void remove_items(double *list, int *length, int k, int *julias_kill);
void external_archive();
void box(double *myvector, double *epsi, double *b, int k);
void print_vec(double *myvector, int k);
void print_genotype(int *gen, int len);
void backtrack(double *myvector, int k, int *num_vecs);
void update_epsi(double *epsi, int k);
void copy_vector(double *from, double *to, int n, int k);
void insertion_sort(double *vec, int n, int k);

double mydrand();
void aga(double *vp, double *newpoint, int k, int *num_vecs);
void update_grid(double *newpoint, double *vp, int num_vecs, int k);
int get_index_nue(int num_vecs, double *vp);
void sphere(C *c);



/* End of JK's stuff */

/* Global variables for clustering */
  gaclust * cl;
  int ** neighbours; 


/* FUNCTIONS */


int addmp(C *c);
int read_adb_data();  /* reads the data  == datafile at the end */
double getdouble(FILE *, double *, int); /* used by read_adb_data */
double eval_adb(C *c); /*  the eval function */
double mmin(double,double); /* used in eval_adb */
double mmax(double,double); /* ditto */

double var = 0.0;


double square(double x) {
    return x*x;
}


//#include <jni.h>
#include "mockvis.h"
#include <stdio.h>

// Parameter 1: run number
// Parameter 2: conf.file
// Parameter 3: setting

//JNIEXPORT void JNICALL Java_mockvis_runmock (JNIEnv *env, jobject obj, jint nbr) {
int main(int argc, char **argv) { 

  double *seq;
  double x;
  int i, j, k;

  
  jobnbr = atoi(argv[1]);//nbr;
  srand(jobnbr);

  // Interaction wit Java
  /*  jclass cls = (env)->GetObjectClass(obj);
  jfieldID fid;
  jfieldID lid;
  jstring jstr;
  const char *str;
  jint si;

  fid = (env)->GetStaticFieldID(cls, "current", "I");
  if (fid == 0) {
    return;
  }

  lid = (env)->GetStaticFieldID(cls, "lock", "I");
  if (lid == 0) {
    return;
    }*/


  // MOCK parameters
  int ST = 1;    // number of EA runs on the original data set 
  int CT = 5;    //5 // number of control sets
  //  MAXNO = 25; // maximum number of clusters

  
  prflag=0;

  cl = new gaclust();
  setting=atoi(argv[2]);
  cl->globalinit(setting);
 

  // default values
  par->normalize = false;
  par->distance = EUCLIDEAN;
  par->userid = atoi(argv[6]);
  par->runid = atoi(argv[7]);



  // Read in parameters from configuration file
  ifstream in("algo/System.conf");
  char temp[1000];
  in >> temp;
  filename = temp;
  in >> globalsize;
  in >> globaldim;
  globaldim = globaldim-1;


  filename=argv[3];
  strcpy(par->filename,filename);
  globalsize=atoi(argv[4]);
  globaldim=atoi(argv[5]);

  int temp2;
  in >> temp2;
  if (temp2 == 0) par->distance = EUCLIDEAN;
  else if (temp2 == 1) par->distance = COSINE;
  else if (temp2 == 2) par->distance = CORRELATION;
  else if (temp2 == 3) par->distance = JACCARD;


  in >> temp2;
  if (temp2 == 0) par->normalize = false;
  else par->normalize = true;
  in >> temp2;
  L = temp2;
  in >> temp2;
  MAXNO = temp2;
  in >> temp2;
  CT = temp2;
  
 
  ipsize = MAXNO*2;
  
  epsize = 1000;
  gsize = globalsize;
  
  nobjs = 2;   
  iterations = 1000;
  nbits = 20;
  cross_rate = 0.7;
  cross_type = 1;
  mute_rate = 1.0/double(gsize);
  rgmutate = 1;
  if (nobjs < 2) psep = 0;
  else psep = 1.0;	
  strcpy(fun,"cl->evaluate");
  grid = 10;
  seed = time(NULL);
  selmeth = 2;
  nalleles = MAXNO;
  prindex = 0;
    
  cl->init(filename);
 
    neighbours = new int * [gsize];
    for (int i=0; i<gsize; i++) {
      neighbours[i] = new int[gsize-1];
    }
 
 
    int st_epsize[ST];
    C * st_ep[ST]; 
    double st_var[ST];
    int st_curepsize = 0;
    
    cl->nnlist(neighbours);
    
     
    // Cluster data set

    for (int st=0; st<ST; st++) {
      
      initialize();
      
   
      for(i= 0; i <iterations; i++)
      {
	it = i;
	
	archivend();  // for each nondominated members of ip, archive it 

	ipsize = 10;

	reproduce();  // update population 

	// Interaction wit Java
	/*	(env)->SetStaticIntField(cls, lid, 1);
	(env)->SetStaticIntField(cls, fid, i+1);
	(env)->SetStaticIntField(cls, lid, 0);
	*/
	for (int i=0; i<curepsize; i++) {
	  prflag=0;

	  prflag2=0;
	  
	  epindex = i;
	  evaluate(&ep[i]);
	  prflag=0;
	  prflag2=0;
	  
	}	 
     
      }
    
    for (int i=0; i<curepsize; i++) {
      prflag=1;
      prflag2=1;
      epindex = st_curepsize+i;
      evaluate(&ep[i]);
     
      prflag=0;
      prflag2=0;
    }	

    st_var[st] = var;
 
    st_ep[st] = ep;
    st_epsize[st] = curepsize;
    st_curepsize += curepsize;
  }
   
   int s_maxno = 0;
   int s_minno = 0;
   for (int st=0; st<ST; st++) {
    int temp = 0;
    for (int i=0; i<st_epsize[st]; i++) {
      temp = max(temp, st_ep[st][i].num);
    }
    if (s_maxno == 0) s_maxno = temp;
    else s_maxno = min(temp, s_maxno);
    if (s_minno == MAXNO) s_minno = temp;
    else s_minno = max(temp, s_minno);
  }
   


  int ct_curepsize = 0;
  int ct_epsize[CT];
  C * ct_ep[CT]; 
  double ct_var[CT];

  mute_rate = 1.0/double(gsize);
  
  // Cluster control data
  for (int ct=0; ct<CT; ct++) {

    ipsize = MAXNO*2;
    // Generate control data
    bin->uniformprescription();
    cl->nnlist(neighbours);
    initialize();

    
   
    for(i= 0; i <iterations; i++)
      {
	it = i;
	
	archivend();  /* for each nondominated members of ip, archive it */
	ipsize = 10;
	reproduce();  /* update population */


	// Interaction wit Java
	/*	(env)->SetStaticIntField(cls, lid, 1);
	(env)->SetStaticIntField(cls, fid, (ct+1)*500+i+1);
	(env)->SetStaticIntField(cls, lid, 0);
	*/
	   
	for (int i=0; i<curepsize; i++) {
	  prflag=0;
	  prflag2=0;
  
	  epindex = i;
	  evaluate(&ep[i]);
	  prflag=0;
	  prflag2=0;
	  
	  
 	}	 
      }
    ct_var[ct] = var;
    ct_epsize[ct] = curepsize;
    ct_curepsize += curepsize;
    ct_ep[ct] = ep;
  }

  
 
  // Ranking of solutions and automatic k-determination 
 

  double * solution = new double [st_curepsize*STEP];
  double * control = new double [ct_curepsize*STEP];


  double s_min0[ST];
  double s_max0[ST];
  double s_min1[ST];
  double s_max1[ST]; 
  double c_min0[CT];
  double c_max0[CT];
  double c_min1[CT];
  double c_max1[CT];

  
  for (int st=0; st<ST; st++) {
    s_min0[st] = 0;
    s_max0[st] = 0;
    s_min1[st] = st_var[st];
    s_max1[st] = st_var[st];
  }

  for (int ct=0; ct<CT; ct++) {
    c_min0[ct] = 0;
    c_max0[ct] = 0;
    c_min1[ct] = ct_var[ct];
    c_max1[ct] = ct_var[ct];

  }


  // Determine largest shared number of clusters
  int c_maxno = 0;
  int c_minno = MAXNO;
  for (int ct=0; ct<CT; ct++) {
    int temp = 0;
    for (int i=0; i<ct_epsize[ct]; i++) {
      temp = max(temp, ct_ep[ct][i].num);
    }
    if (c_maxno == 0) c_maxno = temp;
    else c_maxno = min(temp, c_maxno);
    if (c_minno == MAXNO) c_minno = temp;
    else c_minno = max(temp, c_minno);

  }

  int maxno = min(MAXNO,min(s_maxno, c_maxno));
  int minno = max(MINNO,max(s_minno, c_minno));
  
  int ctr = 0;
 
   for (int st=0; st<ST; st++) {
     for (int i=0; i<st_epsize[st]; i++) {  
    
      solution[ctr*STEP+0] = double(i);
      solution[ctr*STEP+1] = double(st_ep[st][i].num);
      solution[ctr*STEP+2] = st_ep[st][i].o[0];
      solution[ctr*STEP+3] = st_ep[st][i].o[1];
      if (solution[ctr*STEP+1] <= maxno ) {
	s_min0[st] = min(s_min0[st], solution[ctr*STEP+2]);
	s_min1[st] = min(s_min1[st], solution[ctr*STEP+3]);
	s_max0[st] = max(s_max0[st], solution[ctr*STEP+2]);
      }
      ctr++;
     }
    
  }

   

  ctr = 0;
  for (int ct=0; ct<CT; ct++) {
    for (int i=0; i<ct_epsize[ct]; i++) {
      control[ctr*STEP+0] = double(i);
      control[ctr*STEP+1] = double(ct_ep[ct][i].num);
      control[ctr*STEP+2] = ct_ep[ct][i].o[0];
      control[ctr*STEP+3] = ct_ep[ct][i].o[1];
      if (control[ctr*STEP+1] <= maxno  ) {
		c_min0[ct] = min(c_min0[ct], control[ctr*STEP+2]);
		c_min1[ct] = min(c_min1[ct], control[ctr*STEP+3]);
		c_max0[ct] = max(c_max0[ct], control[ctr*STEP+2]);
      }
      ctr++;
    }
  }
  


  // Normalization of objective values

  char name[100];
  sprintf(name, "algo/data/user.%d.method.%d.run.%d.pf",par->userid,setting,par->runid);
  ofstream out1(name);
  
  int N = 1;
  ctr = 0;
  for (int st=0; st<ST; st++) {
    for (int i=0; i<st_epsize[st];i++ ) {
      solution[ctr*STEP+2] = sqrt((solution[ctr*STEP+2]-s_min0[0])/(s_max0[0]-s_min0[0]));
      if (solution[ctr*STEP+3] <= s_min1[0]) {
	solution[ctr*STEP+3]= 0.0;
	solution[ctr*STEP+2]= 1.0;
      }
      else solution[ctr*STEP+3] = sqrt((solution[ctr*STEP+3]-s_min1[0])/(s_max1[0]-s_min1[0]));  
      if (solution[ctr*STEP+1] <= 25) {
	out1 << ctr << " " << solution[ctr*STEP+1] << " " << solution[ctr*STEP+2] << " " << solution[ctr*STEP+3] << " " << st_ep[st][i].f << " "; //
	out1 << st_ep[st][i].sil << " ";
	for (k=0;k<7;k++) {
	  out1 << st_ep[st][i].e[k] << " ";
	}
	out1 << endl;
      }
      ctr++;
	
    }
  }
  out1.close();

  sprintf(name, "algo/data/user.%d.method.%d.run.%d.control.pf",par->userid,setting,par->runid);

  ofstream out2(name);
  N = 1;
  double av[21][2];
  ctr = 0;
  for (int ct=0; ct<CT; ct++) {
    for (int i=0; i<ct_epsize[ct];i++ ) {
      control[ctr*STEP+2] = sqrt((control[ctr*STEP+2]-c_min0[ct])/(c_max0[ct]-c_min0[ct]));
      if (control[ctr*STEP+3] <= c_min1[ct]) {
	control[ctr*STEP+3]=0.0;
	control[ctr*STEP+2]=1.0;
      }
      else control[ctr*STEP+3] = sqrt((control[ctr*STEP+3]-c_min1[ct])/(c_max1[ct]-c_min1[ct]));
      out2 << ctr << " " << control[ctr*STEP+1] << " " << control[ctr*STEP+2] << " " << control[ctr*STEP+3] <<  endl;
      ctr++;
	
    }
  }
  out2.close();
  

  // Only consider non-dominated solutions
  bool snondom[st_curepsize];
  bool ssdom[st_curepsize];
  for (int i=0; i<st_curepsize; i++) {
    snondom[i] = true;
    ssdom[i] = false;
  }
  ctr = st_curepsize;
  for (int i=0; i<st_curepsize; i++) {
    if (solution[i*STEP+1] > maxno) {
      snondom[i] = false;
      continue;
    
    }
   
    for (int j=0; j<st_curepsize; j++) {
      if (i==j || snondom[j] == false) continue;
      if (compare_min(&(solution[j*STEP+2]), &(solution[i*STEP+2]), 2) == 1) {
	snondom[i] = false;
	ssdom[i] = true;
	ctr--;
	break;
      }
    }
    if (snondom[i] == false) continue;
    for (int j=0; j<ct_curepsize; j++) {
	if (compare_min(&(control[j*STEP+2]), &(solution[i*STEP+2]), 2) == 1) {
	  snondom[i] = false;
	  ctr--;
	  break;
	}
    }
  }



  // Determine attainment scores for all solution points

  double dist[st_curepsize];
  double c_dist[ct_curepsize];
  for (int i=0; i<st_curepsize; i++) {
    dist[i] = 0;
  }
 
  for (int i=0; i<st_curepsize; i++) {
    int n = 0;
    dist[i] = 0.0;
    double local_dist[CT]; 

    int k = int(solution[i*STEP+1]); 
    if ( solution[i*STEP+1] == 1 || solution[i*STEP+1] > maxno ) continue;
 
    for (int ct = 0; ct<CT; ct++) {
      local_dist[ct] = attainmentcut(&(solution[i*STEP]), &(control[n*STEP]), ct_epsize[ct], 2); 
      n+= ct_epsize[ct];
    }
     dist[i] = median(local_dist, CT);
   }


  sprintf(name, "algo/data/%d-attainment.pf",jobnbr);
  ofstream att(name);

  int besti = -1;
  double best = 0.0;
  double last = 0.0;




  double best_a[ST+1][s_maxno+1][2];
  for (int st=0; st<=ST;st++) {
    for (int i=0; i<=maxno; i++) {
      best_a[st][i][0] = 0.0;
    }
  }
  
  ctr = 0;

  for (int st=0; st<ST; st++) {
    for (int i=0; i<st_epsize[st]; i++) {
      if (snondom[ctr] == true  ) {
	att << solution[ctr*STEP+1] << " " << dist[ctr] << " " << " " << st_ep[st][i].f << endl;
	int c = int(solution[ctr*STEP+1]);
	best_a[st][c][0] = max(best_a[st][c][0], dist[ctr]);
	if (best_a[st][c][0] == dist[ctr]) {
	  best_a[st][c][1] = ctr;
	}
      }
      else {
	att << solution[ctr*STEP+1] << " " << 0.0 << " " << st_ep[st][i].f << endl;
      }
    
      ctr++;
    }
  }


  

  
  for (int i=2; i<=maxno; i++) {
    for (int st=0; st<ST; st++) {
      best_a[ST][i][0] = max(best_a[ST][i][0],best_a[st][i][0]);
      if (best_a[ST][i][0] == best_a[st][i][0]) {
	best_a[ST][i][1] = best_a[st][i][1];
      }
    }
  }
    
  
  double bestscore = 0.0; 
  for (int i=2; i<=maxno; i++) {
    bestscore = max(bestscore, best_a[ST][i][0]);
    if (bestscore > 0  && best_a[ST][i][0] == bestscore) {
      besti = int(best_a[ST][i][1]);
    }
  }

  sprintf(name, "algo/data/user.%d.method.%d.run.%d.rec.pf",par->userid,setting,par->runid);
  ofstream rec(name);

  
  if (besti == -1) {
    cout << "No solutions selected: all solution points dominated by reference points" << endl;
  }
  else {
       
    rec << besti << " " << solution[besti*STEP+0] << " " << solution[besti*STEP+1] << " " << solution[besti*STEP+2] << " " <<  solution[besti*STEP+3] << " " <<  bestscore << " " << st_ep[0][besti].f << endl;
    
    // Output all local maxima
    ctr = 2;
    bool active = false;
    int lasti = 0;
    double last = -1;
    for (int i=2; i<=maxno; i++) {
      if (best_a[ST][i][0] == 0) continue;
      if (best_a[ST][i][0] < last && active == true) {
	besti = int(best_a[ST][lasti][1]);
	rec << besti << " " << solution[besti*STEP+0] << " " << solution[besti*STEP+1] << " " << solution[besti*STEP+2] << " " <<  solution[besti*STEP+3] << " " <<  last << " " << st_ep[0][besti].f << endl;
      }
      if (best_a[ST][i][0] > last) active = true;
      else active = false;
      last = best_a[ST][i][0];
      lasti = i;
    }
  }
    
}



bool lt (const void *a, const void *b) {

    if (*(double*)a < *(double*)b)
	return true;
     else return false;
}


void print_vec(double *myvector, int k)
{
  int i;
  for(i=0;i<k;i++)
    printf("%lf ",myvector[i]);
  printf("\n");
}

void box(double *myvector, double *epsi, double *b, int k)
{
  int i;
  int dummy;
  for(i=0;i<k;i++)
    {
      if(myvector[i]>0)
	dummy=(int)(log(myvector[i])/(log(1+epsi[i])));
      else
	{
	  fprintf(stdout,"Domain error: myvector is\n");
	  print_vec(myvector,k);
	  exit(1);
	}      
      
      b[i]=(double)dummy;
    }
}

int eps_Pareto(double *vp, double *newpoint, int k, double *epsi, int *num_vecs)
{
  int i,j;
  int result;
  int flag=0;
  double boxnew[k];
  double boxarc[k];

  for(i=0;i<*num_vecs+1;i++)
    julias_kill[i]=0;

  box(newpoint,epsi,boxnew,k);

  /* print_vec(newpoint,k);
  for(i=0;i<*num_vecs;i++)
    {
      print_vec(&(vp[i*k]),k);
    }
  */

  for(i=0;i<*num_vecs;i++)
    {
      //  printf("i=%d:Comparing: ",i);
      // print_vec(boxnew,k);
      // printf("and ");
      

      box(&(vp[i*k]),epsi,boxarc,k);
      // print_vec(boxarc,k);
      result = dom(boxnew, boxarc, k);

      // printf("The result is: %d\n", result);
      //   getchar();
      if(result==1) // it is in a dominating box
	{
	  julias_kill[i]=1;
	  flag=1;
	}
      else if(result==-1) // it is in a box that is dominated
	return(0);
      else if (equal(boxnew,boxarc,k)==1) // it is in the same box as another
	{
	  if(dom(newpoint,&vp[i*k], k)==1) // and it dominates the point in that box
	    {
	      for(j=0;j<k;j++)
		vp[i * k + j]= newpoint[j];
	      return(0);	   
	    }
	  else  // but it does not dominate its box companion
	    return(0);
	}
    }
  
  if(flag==1) // it is in a dominating box
    {
      for(i=0;i<k;i++)
	vp[*num_vecs * k + i]= newpoint[i];
      julias_kill[*num_vecs]=0;
      (*num_vecs)++;
      remove_items(vp,num_vecs,k,julias_kill);
      return(0);
    }
  else // it is in an empty non-dominated box 
    {
      for(i=0;i<k;i++)
	vp[*num_vecs * k + i]= newpoint[i];
      (*num_vecs)++;
      return(0);
    }

}

int equal(double *first, double *second, int n)
{
  // checks to n-dimensional vectors of objectives to see if they are identical
  // returns 1 if they are, 0 otherwise

  int obj = 0;
  
  do
    {
      if(*first!=*second)
	return(0);
      first++;
      second++;
      obj++;
      // printf("%d\n",obj);
    }
  while(obj < n);
  return(1);
}


int eps_dom(double *first, double *second, int k, double *epsi)
{
  int result;
  int i=0;
  double trans_point[nobjs];

  
  if (MINMAX==0)
    {
      for(i=0;i<k;i++)
	{
	  trans_point[i] = (1.0/(1.0+epsi[i]))*first[i];
	}
      result = compare_min(trans_point, second, k);
    }
  
  else
    {
      for(i=0;i<k;i++)
	{
	  trans_point[i] = (1.0+epsi[i])*first[i];
	}
      result = compare_max(trans_point, second, k);
    }
  
  return(result);  	  
}

int dom(double *first, double *second, int n)
{
  int result;
  if (MINMAX==0)
    result = compare_min(first, second, n);
  else
    result = compare_max(first, second, n);
  return(result);  	  
}

int compare_max(double *first, double *second, int n)
{
  // as for compare_min() but for maximization problems 
  
  int obj = 0;
  int deflt = 0;
  int current;
  
  do 
    {
      if(*first > *second)
	current = 1;
      else if(*second > *first)
	current = -1;
      else
	current = 0;
      if((current)&&(current==-deflt))
	{
	  return(0);
	}
      if(current!=0)
	{
	  deflt = current;
	}
      obj++;
      first++;
      second++;
    }while(obj < n);
  return(deflt);
}

int compare_min(double *first, double *second, int n)
{
  // compares two n-dimensional vectors of objective values for minimization problems
  // returns 1 if first dominates second,
  // -1 if second dominates first, and 0 otherwise

  int obj = 0;
  int deflt = 0;
  int current;
  
  do 
    {
      
      if(*first < *second)
	current = 1;
      else if(*second < *first)
	current = -1;
      else
	current = 0;
      if((current)&&(current==-deflt))
	{
	  
	  return(0);
	}
      if(current!=0)
	{
	  deflt = current;
	}
      obj++;
      first++;
      second++;
    }while(obj < n);
  
  return(deflt);
}

void calculate_ranges(double *vp, int k, int num_vecs)
{
  int i,j;


  for(i=0;i<k;i++)
    {
      jmin[i]=2000000000;
      jmax[i]=-2000000000;
      for(j=0;j<num_vecs;j++)
	{
	  if(vp[j*k+i]<jmin[i])
	    jmin[i]=vp[j*k+i];
	  if(vp[j*k+i]>jmax[i])
	    jmax[i]=vp[j*k+i];
	}      
    }
  //  printf("jmin=");
  //print_vec(jmin,k);
  // printf("jmax=");
  //print_vec(jmax,k);


}

void update_epsi(double *epsi, int k)
{
  int i,j;
  double R[k];
  double kay;

  kay=-1;
  for(i=0;i<k;i++)
    {
      R[i]=(jmax[i]/jmin[i]);
      if(R[i]<0)
	R[i]*=-1;
      if(R[i]>kay)
	kay=R[i];
    }
  for(i=0;i<k;i++)
    epsi[i]=pow(double(kay),double(1.0/(pow(int(max_arc),double(1.0/(k-1))))))-1.0;

  // printf("new epsi=");
  // print_vec(epsi,k);

}

void external_archive()
{
  int i,j;
  int update_type=1;

  for(i=0;i<ipsize;i++)
    {
      iter++;
      if(update_type == 1)
	{	  
	  eps_approx(myvector, ip[i].o, 0, nobjs, epsi, &num_vecs);

	}
          
      else if(update_type == 2)
	{
	  //	  printf("myvector = %lf, %lf\n", ip[i].o[0], ip[i].o[1]);
	  eps_Pareto(myvector, ip[i].o, nobjs, epsi, &num_vecs);
	}
      
      else if(update_type == 3)
	{
	  // printf("calling aga with num_vecs=%d\n", num_vecs);
	  // printf("myvector = %lf, %lf\n", ip[i].o[0], ip[i].o[1]);
	  aga(myvector, ip[i].o, nobjs , &num_vecs);
	}
      
      else
	exit(1);
    }
    
}

void eps_approx(double *vp, double *newpoint, int ts, int k, double *epsi, int *num_vecs)
{
  static int t=1;
  static int restart=0;
  int result,result2;
  int i,j;
  int domed=0;  
  int doming=0;
  int changed=0;


  // check ranges for changes
  if(restart==1)
    {
      for(j=0;j<k;j++)
	{
	  if(newpoint[j]>jmax[j])
	    {
	      jmax[j]=newpoint[j];
	      changed=1;
	    }
	  else if(newpoint[j]<jmin[j])
	    {
	      jmin[j]=newpoint[j];
	      changed=1;
	    }
	}
    }
  if(changed==1)
    {
      update_epsi(epsi,nobjs);	  
      backtrack(myvector,nobjs,num_vecs);
    }

  for(i=0;i<*num_vecs+1;i++)
    julias_kill[i]=0;

  // printf("the new point is: ");
  // print_vec(newpoint,nobjs);
  
  // print_vec(&(vp[0]),k);

  for(j=0;j<*num_vecs;j++)
    {
      result2=dom(newpoint,&(vp[j*k]),k);
      result=eps_dom(&(vp[j*k]),newpoint,k,epsi);
      
      if(result==1)
	{
	  j=*num_vecs;
	  domed=1;
	}
      else if(result2==1)
	{
	  julias_kill[j]=1;
	  doming=1;
	}
    }
  
  if(!domed)
    {
      for(i=0;i<k;i++)
	vp[*num_vecs * k + i]= newpoint[i];
      if(!ts)
	timestamps[*num_vecs]= t; 
      else
	timestamps[*num_vecs]=ts;
      (*num_vecs)++;
      
      printf("num_vecs=%d\n",*num_vecs);

      if(doming==1)
	remove_items(vp,num_vecs,k,julias_kill);      

      /* else if(*num_vecs>max_arc)
	{
	  calculate_ranges(myvector,nobjs,*num_vecs);
	  update_epsi(epsi,nobjs);	  
	  backtrack(myvector,nobjs,num_vecs);
	  }*/

      if((epsi[0]==0.0)&&(*num_vecs==2)&&(restart==0))
	{
	  printf("eps[0]=%lf, myvector=%d\n",epsi[0],*num_vecs);
	  calculate_ranges(myvector,nobjs,*num_vecs);
	  update_epsi(epsi,nobjs);
	  printf("Phew -- setting epsi to ");
	  print_vec(epsi,nobjs);
	  restart=1;
	  getchar();
	}

    }
  if(ts==0)
    t++;
}


void aga(double *vp, double *newpoint, int k, int *num_vecs)
{
  int result=0;
  int doming=0;
  int domed=0;
  int extends=0;
  int incrowded;
  static int fall=0;
  int i,j;


  if(*num_vecs>=max_arc)
    {
      for(i=0;i<k;i++)
	vp[*num_vecs * k + i]= newpoint[i];  // add the new point to the list (just temporarily)
      calculate_ranges(vp,k,*num_vecs);
      // printf("ranges calculated!\n");
      for(j=0;j<k;j++)
	{
	  if(newpoint[j]>jmax[j])
	    extends=1;
	  if(newpoint[j]<jmin[j])
	    extends=1;
	}
      
      update_grid(newpoint,vp,*num_vecs+1,k);

	  //	  compute_nue();  
      
    }

  for(i=0;i<*num_vecs+1;i++)
    julias_kill[i]=0;


  //  printf("doming=%d\n",doming);
  for(j=0;j<*num_vecs;j++)
    {
      result=dom(newpoint,&(vp[j*k]),k);
      if (result==-1)
	{
	  domed=1;
	  j=*num_vecs;
	}
      else if(result==1)
	{
	  //  printf("f");
	  julias_kill[j]=1;
	  doming=1;
	}
    }
  // printf("doming=%d\n",doming);


  if(domed==0)
    {
      // printf("I'm nondominated!\n");
      if(doming==1)
	{
	  // printf("I'm dominating\n");
	  remove_items(vp,num_vecs,k,julias_kill);
	  for(i=0;i<k;i++)
	    vp[*num_vecs * k + i]= newpoint[i];
	  (*num_vecs)++;	  
	}
      else if(*num_vecs>=max_arc)
	{
	  if(extends==1)
	    {
	      // printf("and I extend..\n");
	      // getchar();
	      julias_kill[get_index_nue(*num_vecs,vp)]=1;	      
	      //	      for(i=0;i<*num_vecs+1;i++)
	      //	printf("%d",julias_kill[i]);
	      // printf("\n");
	      remove_items(vp,num_vecs,k,julias_kill);
	      for(i=0;i<k;i++)
		vp[*num_vecs * k + i]= newpoint[i];	     
	      (*num_vecs)++;
	    }	  
	  else 
	    {
	      incrowded=FALSE;
	      //  printf("$$$$$$$$$$$$$$$$$$$$$$$$$ num_cr=%d\n", num_cr);
	      // printf("$$$$$$$$$$$$$$$$$$$$$$$$$ location = %d, crowded region0=%d\n", find_loc(newpoint),crowded_region[0]);
	      for(i=0;i<num_cr;i++)
		if(find_loc(newpoint)==crowded_region[i])
		  incrowded=TRUE;
	      if(incrowded==FALSE)
		{
		  //  printf("and I am not in a most crowded region\n");
		  // getchar();
		  julias_kill[get_index_nue(*num_vecs,vp)]=1;	      
		  remove_items(vp,num_vecs,k,julias_kill);
		  for(i=0;i<k;i++)
		    vp[*num_vecs * k + i]= newpoint[i];	    
		  (*num_vecs)++;
		}
	      else
		{
		  //	  printf("I suppose I must be in a most crowded region!!!!\n");
		}
	    }
	}
      else
	{
	  //  printf("And I should be added\n");
	  for(i=0;i<k;i++)
	    vp[*num_vecs * k + i]= newpoint[i];
	  (*num_vecs)++;
	}
    }
  //  else
    // printf("I am dominated\n");
 
  /*
  1. update ranges and grid boundaries
  2. if (result != -1)
     3. if (result == 1)
        4. archive new point and remove all dominated
     5. else if (archive is full)
        6. if (new point extends the ranges)
           7. add the new point and remove a non-extremal from the most crowded
	8. else if (new point not in a most crowded region) 
           9. add the new point and remove a non-extremal from the most crowded
     10 else
          11. archive the new point
  */
    
}


int get_index_nue(int num_vecs, double *vp)
{
  // get any point from a crowded region except if it uniquely extremal
  int num;
  int i,j;
  int incrowded;
  do
    {
      incrowded=0;
      num=myrand(num_vecs);
      // printf("trying %d\n",num);
      for(i=0;i<num_cr;i++)
	if(find_loc(&vp[num*nobjs])==crowded_region[i])
	  incrowded=1;
      
    }
  while((incrowded==0)||(uev[num]==1));

  return num;
}

void update_grid(double *newpoint, double *vp, int num_vecs, int k)
{
  int a, b, tmp, i, j;
  int square;
  double offset[MAX_OBJ];
  int out;

  static double old_ub[MAX_OBJ];
  static double old_lb[MAX_OBJ];
  double ub[MAX_OBJ];
  double lb[MAX_OBJ];
  int unique; // counter
  int list_uev[20]; // list of those that are uniquely extremal
  int nue;  // number of uniquely extremal vectors
  int cf_max; // maximum crowding factor
  
  for(a=0;a<k;a++)
    {
      ub[a]=jmax[a]+(1.0/(2*depth))*(jmax[a]-jmin[a]);
      lb[a]=jmin[a]-(1.0/(2*depth))*(jmax[a]-jmin[a]);
    }
 
  out=FALSE;
  for(a=0;a<k;a++)
    {
      if((old_ub[a]!=ub[a])||(old_lb[a]!=lb[a]))
	out=TRUE;
    }
  /* if(out)
    {
      fprintf(stderr,"%d ",iter);
      for(a=0;a<k;a++)     
	fprintf(stderr,"%lf %lf ",jmin[a], jmax[a]);   
      fprintf(stderr,"\n");
      }*/
  
  unique=0;

  for(j=0;j<num_vecs;j++)
    uev[j]=0;

  for(i=0;i<nobjs;i++)
    {
      for(j=0;j<num_vecs;j++)
	{
	  if(vp[j*nobjs+i]==jmax[j])
	    {
	      unique++;
	      if(unique==1)
		tmp=j;
	    }
	}
      if(unique==1)
	{
	  uev[tmp]=1;
	}

      unique=0;
      for(j=0;j<num_vecs;j++)
	{
	  if(vp[j*nobjs+i]==jmin[j])
	    {
	      unique++;
	      if(unique==1)
		tmp=j;
	    }
	}
      if(unique==1)
	{
	  uev[tmp]=1;
	}
    }

  nue=0;
  for(j=0;j<num_vecs;j++)
    {
      if(uev[j]==1)
	{
	  list_uev[nue]=j;
	  nue++;
	}
    }
  /* printf("Uniquely extremal vectors:\n");
  for(j=0;j<num_vecs;j++)
    {
      printf("%d",uev[j]);
    }
  */
  for (a = 0; a < pow(double(2), double(k*depth)); a++)
    {
      grid_pop[a] = 0;
    }
  
  for (a = 0; a < num_vecs; a++)
    {
      square = find_loc(&vp[a*nobjs]);
      // printf("square=%d\n", square);
      loc[a] = square;
      if(uev[a]!=1)
	grid_pop[square]++;      
    }
  cf_max=-1;
  for (a = 0; a < pow(double(2), double(k*depth)); a++)
    {
      if(grid_pop[a] > cf_max)
	cf_max=grid_pop[a];
    }
  num_cr=0;
  for(a=0;a<20;a++)
    crowded_region[a]=-1;
  for (a = 0; a < pow(double(2), double(k*depth)); a++)
    {
      if(grid_pop[a]==cf_max)
	{
	  crowded_region[num_cr]=a;
	  num_cr++;
	}
    }  
  for (a = 0; a < k; a++)
    {
      old_lb[a]=lb[a];
      old_ub[a]=ub[a];
    }
}

int find_loc(double *eval)
{
  // find the grid location of a solution given a vector of its objective values

  int loc = 0;
  int d;
  int n = 1;
  
  int i;
  
  int inc[MAX_OBJ];
  double width[MAX_OBJ];
  double offset[MAX_OBJ];

  for (i = 0; i < nobjs; i++)
    {
      offset[i]=jmin[i]-(1.0/(2*depth))*(jmax[i]-jmin[i]);
      inc[i] = n;
      n *=2;
      width[i] = (1.0+(1.0/(2*depth)))*(jmax[i]-jmin[i]);
    }
	    
  for (d = 1; d <= depth; d++)
    {
      for (i = 0; i < nobjs; i++)
	{
	  if(eval[i] < width[i]/2+offset[i])
	    loc += inc[i];
	  else
	    offset[i] += width[i]/2;
	}
      for (i = 0; i < nobjs; i++)
	{
	  inc[i] *= (nobjs *2);
	  width[i] /= 2;
	}
    }
  return(loc);
} 

/*

void eps_diminish(double *vp, double *newpoint, int ts, int k, double *epsi, int *num_vecs)
{
// This function maintains an archive that is not actually guaranteed epsi-approximate but
//   which allows epsi to be diminished as well as increased 

  static int t=1;
  static int restart=0;
  int arcsize_limit=10;
  int result,result2;
  int i,j;
  int domed=0;  
  int doming=0;
  int changed=0;

   
  // check ranges for changes
  if(restart==1)
    {
      for(j=0;j<k;j++)
	{
	  if(newpoint[j]>jmax[j])
	    {
	      jmax[j]=newpoint[j];
	      changed=1;
	    }
	  else if(newpoint[j]<jmin[j])
	    {
	      jmin[j]=newpoint[j];
	      changed=1;
	    }
	}
    }
  if(changed==1)
    {
      update_epsi(epsi,nobjs);	  
      backtrack(myvector,nobjs,num_vecs);
    }
  

  for(i=0;i<*num_vecs+1;i++)
    julias_kill[i]=0;

  // printf("the new point is: ");
  // print_vec(newpoint,nobjs);
  
  // print_vec(&(vp[0]),k);

  for(j=0;j<*num_vecs;j++)
    {
      result2=dom(newpoint,&(vp[j*k]),k);
      result=eps_dom(&(vp[j*k]),newpoint,k,epsi);
      
      if(result==1)  // if the new point is epsi-dominated by the archive
	{
	  j=*num_vecs;
	  domed=1;
	}
      else if(result2==1)  // if the new point dominates the archive
	{
	  julias_kill[j]=1;
	  doming=1;
	}
    }
  
  if(!domed)
    {
      if ((*num_vecs>=arcsize_limit)&&(doming!=1))
	{
	  // increase epsi and do not let the new point enter
	  epsi *= 1.1;
	}
      else
	{
	  for(i=0;i<k;i++)
	    vp[*num_vecs * k + i]= newpoint[i];
	  if(!ts)
	    timestamps[*num_vecs]= t; 
	  else
	    timestamps[*num_vecs]=ts;
	  (*num_vecs)++;
	}
      //  printf("num_vecs=%d\n",*num_vecs);
      if(doming==1)
	remove_items(vp,num_vecs,k,julias_kill);      

	// else if(*num_vecs>max_arc)
	//{
	//  calculate_ranges(myvector,nobjs,*num_vecs);
	//  update_epsi(epsi,nobjs);	  
	//  backtrack(myvector,nobjs,num_vecs);
	//  }

      if((epsi[0]==0.0)&&(*num_vecs==2)&&(restart==0))
	{
	  calculate_ranges(myvector,nobjs,*num_vecs);
	  update_epsi(epsi,nobjs);
	  //   printf("Phew -- setting epsi to ");
	  // print_vec(epsi,nobjs);
	  restart=1;
	  // getchar();
	}

    }
  if(ts==0)
    t++;
}
*/

void backtrack(double *myvector, int k, int *num_vecs)
{
  int i,j;
  int old_num_vecs;
  double *tv;
  int *ts;

  tv = (double *)malloc(*num_vecs*k*sizeof(double));
  ts = (int *)malloc(*num_vecs*sizeof(int));

  old_num_vecs = *num_vecs;

  insertion_sort(myvector,old_num_vecs,k);
  
  copy_vector(myvector,tv,old_num_vecs,k);

  *num_vecs=0; // deletes the list
  // getchar();
  for(i=0;i<old_num_vecs;i++)
    {
      eps_approx(myvector, &(tv[i*k]), ts[i], k, epsi, num_vecs);
    }
  // printf("There are now %d vectors after changing epsi.\n", *num_vecs);
  // getchar();
}

void copy_vector(double *from, double *to, int n, int k)
{
  int i,j;
  for(i=0;i<n;i++)
    for(j=0;j<k;j++)
      to[i*k+j]=from[i*k+j];
}

void insertion_sort(double *vec, int n, int k)
{
  int c,i,j,v;
  double point[k];

  for(i=1;i<n;i++)
    {
      v=timestamps[i];
      for(c=0;c<k;c++)
	point[c]=vec[i*k+c];
      j=i;
      while(timestamps[j-1]>v)
	{
	  timestamps[j]=timestamps[j-1];
	  for(c=0;c<k;c++)
	    vec[j*k+c]=vec[(j-1)*k+c];
	  j--;
	  if(j==0)
	    break;
	}
      timestamps[j]=v;
      for(c=0;c<k;c++)
	vec[j*k+c]=point[c];
    }
}



void remove_items(double *list, int *length, int k, int *julias_kill)
{
  //  This function removes the items with entry 1 in julias_kill from list.

  int j,i;
  int steps=0;
  int old_length = *length;

  /*
   printf("The list before removing items is:\n");
  for(i=0;i<old_length;i++)
    {
      print_vec(&(list[i*k]),k);
      printf("julias_kill=%d\n",julias_kill[i]);
    }
  */

  i=0;
  while(steps<old_length)
    {
      if(julias_kill[i]==1)
	{
	  // printf("Kill\n");
	  for(j=0;j<k;j++)
            {
	      list[i*k+j]=list[((*length)-1)*k+j];
	      timestamps[i*k+j]=timestamps[((*length)-1)*k+j];
            }
	  julias_kill[i]=julias_kill[(*length)-1];
	  (*length)--;
	  i--;
	}      
      i++;
      steps++;
    }


  // printf("The list length after removing items is: %d\n", *length);
  /*
  for(i=0;i<*length;i++)
    {
      print_vec(&(list[i*k]),k);
    }
  printf("good bye\n");
  */

}

/* copy the nondominated members of ip to ep */

int archivend()
{

  int i, j, k;
//  cout << "ipsize = " << ipsize << endl;

  for(i=0;i<ipsize;i++)
   if(nd(i,ip, ipsize)==1) {
       addtoarchive(i);
   }

}

int nd(int c, C *p, int s)
  {
    /* is c nondom in population p of size s ? */

     int i, r;

     r = 1;

     for(i=0;i<s;i++)
       if(dominates(&p[i],&p[c])) { r = 0; break; }

   return(r);
  }


int dominated(int c, C *p, int s)
{
    /* is c dominated in population p of size s ? */

     int i, r;

     r = 0;

     for(i=0;i<s;i++)
        if(  ( i != c) && (dominates(&p[i],&p[c]))) { r = 1; break; }

	                     return(r);
    }




int covered(int c, C *p, int s)
{
  /* is c covered in population p of size s ? */

       int i, r;

       r = 0;

       for(i=0;i<s;i++)
        if(  ( i != c) && (covers(&p[i],&p[c]))) { r = 1; break; }

		    return(r);
}





/* return 1 if a dominates b, 0 otherwise */
int dominates(C *a, C *b)
  {
   int i, r, abb, bba;

   abb = bba = 0;
  
   if(MINMAX==0)
     {
       for(i=0;i<nobjs;i++)
	 if(a->o[i]>b->o[i]) bba++; 
	 else if (a->o[i]<b->o[i]) abb++;
     }
   else
     {
       for(i=0;i<nobjs;i++)
	 if(a->o[i]<b->o[i]) bba++; 
	 else if (a->o[i]>b->o[i]) abb++;
     }
 
   if((bba==0) && (abb>0)) r = 1; else r = 0;
  

 return(r);
  }



/* return 1 if a covers b, 0 otherwise */
int covers(C *a, C *b)
{
     int i, r, abb, bba;

        abb = bba = 0;
	if(MINMAX==0)
	  {
	    for(i=0;i<nobjs;i++)
	      if(a->o[i]>b->o[i]) bba++;
	      else if (a->o[i]<b->o[i]) abb++;
	  }
	else
	  {
	    for(i=0;i<nobjs;i++)
	      if(a->o[i]<b->o[i]) bba++; 
	      else if (a->o[i]>b->o[i]) abb++;
	  }
	if((bba==0) && (abb>=0)) r = 1; else r = 0;
	
	
	return(r);
}





int addtoarchive(int ch)
  {
   int i, j, k;

   copy_chromosome(&ip[ch],&ep[curepsize++]);
 if(DEBUG)
    printf("chrom %d added to ep -- ep size now %d\n",ch,curepsize);
/*** HERE ***/

 if(covered(curepsize-1,ep,curepsize) ==0)    {

//   cout << "Curepsize = " << curepsize << endl;

  if(curepsize==1)
    {
      /* this is the first thing in the archive */
      for(i=0;i<nobjs;i++)
        davemax[i]=davemin[i] = ip[ch].o[i];
    }
  else {

   
    updateranges(ch);
    filterdom();
    calculateboxes();
    if(curepsize>epsize) reduceep();

  }
   
}  else curepsize--; 

 }

int reduceep()
{
 int i, j, k, bh, bhval;

 bh = 0;
 bhval = boxcount[ep[0].bn];

 for(i=1;i<curepsize;i++)
   if ( boxcount[ep[i].bn]> bhval)
     { bhval = boxcount[ep[i].bn]; bh = i; }

copy_chromosome(&ep[curepsize-1],&ep[bh]);
curepsize--;
}

  
	

int updateranges(int ch)
{
 int i, j, r = 0;	   

 for(i=0;i<nobjs;i++)
  { if(ip[ch].o[i]<davemin[i]) {davemin[i] = ip[ch].o[i]; r = 1;}
    if(ip[ch].o[i]>davemax[i]) {davemax[i] = ip[ch].o[i]; r = 1;}
  }
 return(r);
}
  
int calculateboxes()
{
 int i, j, k, b;
 C *c;
 double low, inc, high, place, range;


  for(i=0;i<(int)(pow(double(grid),double(nobjs)));i++) boxcount[i] = 0;

 
 for(i=0;i<curepsize;i++)
   {
     c = &ep[i];
     c->bn = 0;
     
     for(j=0;j<nobjs;j++)
      {
        range = davemax[j] - davemin[j];
        low = davemin[j]-0.001*range;
        high = davemax[j] + 0.001*range;
        inc = (high - low)/(double)(grid);
        
        place = low;
        b = 0;
        while(c->o[j]>place) {place+=inc; b++;}
        b--;
        c->box[j] = b;
        c->bn += (int)(pow(double(grid),double(j)))*b;
      }
     boxcount[c->bn]++;
   }
}
 


int filterdom()
  {
       int i, j, k;

         for(i=0;i<curepsize;i++)
	      if (dominated(i,ep, curepsize)==1)
		{ copy_chromosome(&ep[curepsize-1],&ep[i]);
		         curepsize--;
		         i--;
     if(DEBUG) printf("... just filtered out chromosome %d from ep\n",i+1);
		}
     }
   


int filter()
  {
   int i, j, k;
  
  for(i=0;i<curepsize;i++)
   if (covered(i,ep, curepsize)==1) 
     { copy_chromosome(&ep[curepsize-1],&ep[i]);
       curepsize--;
       i--;
     if(DEBUG) printf("... just filtered out chromosome %d from ep\n",i+1);
     }
  }


int initialize()
{


 int i, j;
 int dim = par->bindim;
 C *c;

 curepsize = 0;


 int cset[gsize];
 bool in[gsize];
 for (int i=0; i<gsize; i++) {
   cset[i] = -1;
   in[i] = false;
 }
 cset[0] = 0;
 in[0] = true;
 int csize=1;
 int ass[gsize];
 for (int i=0; i<gsize; i++) {
   ass[i] = i;
 }
 
 double edges[gsize*2];
 edges[0] = 0;
 edges[0] = 0;

 double interesting[gsize*2];
 int ictr = 0;
 double smalld = 1e10;
 double larged = -1e10;


 while (csize < gsize) {
   // find edge with minimal distance
   double mind = -1.0;
   int start = -1;
   int end = -1;
   int mink = -1;
   for (int i=0; i<csize; i++) {
     int cel = cset[i];
     int k = 0; 
     while (in[neighbours[cel][k]] != false) k++; 
     double d = bin->precomputed_d(cel, neighbours[cel][k]);
     if ((mind == -1.0) || (d < mind)) {
       mind = d;
       end = neighbours[cel][k];
       start = cel;
       mink = k;
     }
   }

   int kptr = 0;
   for (int h=0; h<gsize-1;h++) {
     if (neighbours[end][h] == start) {
       kptr = h;
       break;
     }
   }

   if ((mink > L) && (kptr > L)) {
     interesting[ictr*2+0] = end;
     interesting[ictr*2+1] = min(mink,kptr);
     ictr++;
     //   cerr << mink << " " << kptr << endl;
   }

   smalld = min(mind, smalld);
   larged = max(mind, larged);
   cset[csize] = end;
   in[end] = true;
   if (csize == 1) ass[start] = end;
   ass[end] = start;

  
   // New one
   edges[end*2]=end;
   edges[end*2+1]=kptr;
   csize++;
 }

 // cerr << "Interesting edges " << ictr << endl;


 // delete bin->distancematrix;
 // bin->distancematrix = NULL;

 ip = (C *)malloc(ipsize*sizeof(C));
 ep = (C *)malloc((epsize+ipsize)*sizeof(C));
 mp = (C *)malloc((ipsize+epsize)*sizeof(C));

 if (ip == NULL || ep == NULL || mp == NULL) {
   cerr << "Error during memory allocation (pesaclust:initialize)" << endl;
   exit(0);
 }



 //MpArraySort(edges, gsize, 2*sizeof(double), 1, 1*sizeof(double), lt);

 
 //qsort((void *)edges, gsize, 2*sizeof(double), int_lt1);
 qsort((void *)interesting, ictr, 2*sizeof(double), int_lt1);

 int first = 0;
  
 for(i=0;i<ipsize;i++)
   { 

     c = &ip[i];
     c->g = (int *)malloc(gsize*sizeof(int));
     c->rank = (int *)malloc(gsize*sizeof(int));
     c->o = (double *)malloc(nobjs*sizeof(double));
     c->box = (int *)malloc(nobjs*sizeof(int));
     c->ind = (double **)malloc(gsize*sizeof(double));
     for (int j=0;j<gsize;j++) {
       c->ind[j]= (double *)malloc(2*sizeof(double));
     }

     evaluation * e = new evaluation(par);
 

     //if (i < 0.5*ipsize) 
     /*     {
       for (int j=0; j<gsize; j++) {
	 c->g[j] = ass[j];
       }
       if (i != 0) {
	
	 for (int m=gsize-1; m>gsize-i-1; m--) {
	     int l = m*2;
	     if (l >= 0) {
	       int index = int(edges[l]);
	       c->g[index] =  index;
	     }
	 }

	 
       }
       else {
	 evaluate(c);
	 var = c->o[1];
       }
       }*/
     

     first = min(ictr,50);

     if (i == 0) {
       for (int j=0; j<gsize; j++) {
	 c->g[j] = ass[j];
	 c->rank[j] = (int)(edges[j*2+1]);
       }
       evaluate(c);
       var = c->o[1];
     }

     else if (i <= first ) 
      {
       for (int j=0; j<gsize; j++) {
	 c->g[j] = ass[j];
	 c->rank[j] = (int)(edges[j*2+1]);
       }
       for (int m=ictr-1; m>=ictr-i; m--) {
	 int l = m*2;
	 if (l >= 0) {
	   //	   cerr << interesting[l] << " " << interesting[l+1] << endl;
	   int index = int(interesting[l]);
	   int index2 = myrand(L);
	   c->g[index] =  neighbours[index][index2];//index;
	   c->rank[index] = index2;
	 }
       }
      }
     
     else {
       
       
       evaluation e(par);
       kmeans * kmeansrun;

       int old = par->kclusters;
       par->kclusters = 1+i-first;//2+i-0.5*ipsize;
       //   cerr << par->kclusters << endl;
       kmeansrun  = new kmeans(par, bin, &e);
       kmeansrun->init();
       kmeansrun->run();
       clustering * cl = kmeansrun->getclustering();
       for (int j=0; j<gsize; j++) {
	 if ((*cl)[j]==(*cl)[ass[j]]) {
	   c->g[j] = ass[j];
	   c->rank[j] = (int)(edges[j*2+1]);
	 }
	 else {
	   int index2 = myrand(L);
	   /*	   c->g[j] = j;
	   c->rank[j] = 0;
	   for (int l=0; l<L; l++) {
	     if ((*cl)[j]==(*cl)[neighbours[j][l]]) {
	       c->g[j] = neighbours[j][l];
	       c->rank[j] = l;
	       break;
	     }
	     }*/
	   c->g[j] = neighbours[j][index2];
	   c->rank[j] = index2;
	 }
       }
       par->kclusters = old;
     }
 
   
 
     evaluate(c);

     //    cout << c->num << " " << c->o[0] << " " << c->o[1] << " " <<  c->f << endl;
   }



 
 myvector = (double *)malloc(100*nobjs*sizeof(double));
 timestamps = (int *)malloc(100*sizeof(int));
 epsi = (double *)malloc(nobjs*sizeof(double));
 jmin = (double *)malloc(nobjs*sizeof(double));
 jmax = (double *)malloc(nobjs*sizeof(double));
 julias_kill = (int *)malloc(100*sizeof(int));

 
 for(i=0;i<epsize+ipsize;i++)
   {
       c = &ep[i];
       c->g = (int *)malloc(gsize*sizeof(int));
       c->rank = (int *)malloc(gsize*sizeof(int));
       c->o = (double *)malloc(nobjs*sizeof(double));
       c->box = (int *)malloc(nobjs*sizeof(int));
       c->ind = (double **)malloc(gsize*sizeof(double));
       for (int j=0;j<gsize;j++) {
	 c->ind[j]= (double *)malloc(2*sizeof(double));
       }
   }

 for(i=0;i<ipsize+epsize;i++)
   {
      c = &mp[i];
      c->g = (int *)malloc(gsize*sizeof(int));
      c->rank = (int *)malloc(gsize*sizeof(int));
      c->o = (double *)malloc(nobjs*sizeof(double));
      c->box = (int *)malloc(nobjs*sizeof(int));
      c->ind = (double **)malloc(gsize*sizeof(double));
      for (int j=0;j<gsize;j++) {
	c->ind[j]= (double *)malloc(2*sizeof(double));
      }
   }
 


 davemax = (double *)malloc(nobjs*sizeof(double));
 davemin = (double *)malloc(nobjs*sizeof(double));

 boxcount = (int *)malloc((int)(pow(double(grid),double(nobjs)))*sizeof(int));
 occboxes = (int *)malloc((int)(pow(double(grid),double(nobjs)))*sizeof(int));

 if(DEBUG==1)
   { print_ip_details();
     print_ep_details();
   }
}


int print_ip_details()
{
  int i, j, k;

  printf("ip size = %d, genes = %d, alleles = %d \n", ipsize, gsize, nalleles);

  for(i=0;i<ipsize;i++)
      print_chromosome(&ip[i],1);
}


int print_ep_details()
{
    int i, j, k;

    printf("ep size = %d (%d), genes = %d, alleles = %d \n", 
   curepsize, epsize, gsize, nalleles);

      for(i=0;i<curepsize;i++)
	      print_chromosome(&ep[i],0);
  }

int print_results()
{ 
  int i, j, k;

  for(i=0;i<curepsize;i++)
   {for (j =0;j<nobjs;j++)
      printf("%f ", ep[i].o[j]);
   printf("\n");
  }
  //  printf("1000000\n");
}


int print_chromosome(C *c, int g)
{
  int i;

 if(g==1)  
   {for(i=0;i<gsize;i++)  printf("%d ", c->g[i]); printf("   chrom\n");}
  for(i=0;i<nobjs;i++)  printf("%f ", c->o[i]); printf("   objs\n");
  printf("%g    strength\n", c->strength);   
   
}

int evaluate(C *c)
{
  /* assign objectives to o.*/ 

  /* HERE1 */

  int i, j;

  if(!strcmp(fun,"T1"))
     t1(c);
 else if(!strcmp(fun,"T2"))
        t2(c);
   else if(!strcmp(fun,"T3"))
          t3(c);
   else if(!strcmp(fun,"T4"))
          t4(c);
   else if(!strcmp(fun,"T5"))
          t5(c);
   else if(!strcmp(fun,"T6"))
          t6(c);
  else if(!strcmp(fun,"F5"))
     ff5(c);
 else if(!strcmp(fun,"F2"))
        f2(c);
   else if(!strcmp(fun,"F3"))
          f3(c);
   else if(!strcmp(fun,"F4"))
          f4(c);
   else if(!strcmp(fun,"F5"))
          ff5(c);
   else if(!strcmp(fun,"F6"))
          addmp(c);
   else if(!strcmp(fun,"co1")) 
        co1(c);
   else if(!strcmp(fun,"co2"))
             co2(c);
   else if(!strncmp(fun,"mx",2)) 
     mx(c,20);//atoi(fun+2));
 else if(!strncmp(fun,"dec3",4))
             dec3(c,atoi(fun+4));
 else if(!strncmp(fun,"dec4",4))
                dec4(c,atoi(fun+4));
  else if(!strncmp(fun,"cir",2)) 
     circles(c);//atoi(fun+2));
  
  else if(!strncmp(fun,"3obj",2)) 
    correl(c);
  else if(!strncmp(fun,"sphere",2)) 
    sphere(c);
  else if(!strncmp(fun,"cl->evaluate",2)) 
    cl->evaluate(c, L);
 else 
   {

  for(i=0;i<nobjs;i++) c->o[i] = (double)gsize;

  for(i=0;i<gsize;i++)
   if(c->g[i]<2) c->o[c->g[i]]--;
	}

}

int mx(C *c, int rl)
{
  static int relabel[100], start = 0;
  int i, score, newchrom[100];
 
  if (start==0) 
    { start = 1;
      for(i=0;i<gsize;i++)
        if (myrand(gsize)<rl)
         relabel[i] = 1; 
         else relabel[i] = 0;
    }


  /* max ones */

   score = gsize;

   for(i=0;i<gsize;i++)
    if(c->g[i]==1) score--;
 
   c->o[0] = score;

  for(i=0;i<gsize;i++)
   if(relabel[i]==0) newchrom[i] = c->g[i];
     else newchrom[i] = (1 - c->g[i]);
 
   score = gsize;

      for(i=0;i<gsize;i++)
	    if(newchrom[i]==1) score--;

         c->o[1] = score;

	 
}


int dec3(C *c, int rl)
{
    static int relabel[100], start = 0;
     int i, j, score, newchrom[100], ones;

        if (start==0)
	  { start = 1;
	        for(i=0;i<gsize;i++)
		          if (myrand(gsize)<rl)
			             relabel[i] = 1;
		         else relabel[i] = 0;
	  }


	/* dec 3 */

     score = 4*gsize/3;

      for(i=0;i<gsize/3;i++)
        {
          ones = 0;
          for(j=0;j<3;j++)
           if(c->g[3*i+j]==1) ones++;
 
         if(ones==0) score -=4;
         else if (ones==1) score -= 1;
         else if (ones==2) score -= 2;
         else if (ones==3) score -= 3;
		       }

        c->o[0] = score;

         for(i=0;i<gsize;i++)
	     if(relabel[i]==0) newchrom[i] = c->g[i];
	      else newchrom[i] = (1 - c->g[i]);



     score = 4*gsize/3;

            for(i=0;i<gsize/3;i++)
	      {
                ones = 0;
                for(j=0;j<3;j++)
	         if(newchrom[3*i+j]==1) ones++;
                  if(ones==0) score -=4;
	          else if (ones==1) score -= 1;
	          else if (ones==2) score -= 2;
	           else if (ones==3) score -= 3;
	   }
            c->o[1] = score;

			    
}
  
  


int dec4(C *c, int rl)
{
   static int relabel[100], start = 0;
   int i, j, score, newchrom[100], ones;


          if (start==0)
     { start = 1;
                    for(i=0;i<gsize;i++)
                   if (myrand(gsize)<rl)
                                   relabel[i] = 1;
                            else relabel[i] = 0;
		     }


		   /* dec 3 */

        score = 5*gsize/4;

      for(i=0;i<gsize/4;i++)
	{
          ones = 0;
             for(j=0;j<4;j++)
	           if(c->g[4*i+j]==1) ones++;
               if(ones==0) score -=5;
                else if (ones==1) score -= 1;
                else if (ones==2) score -= 2;
                else if (ones==3) score -= 3;
                else if (ones==4) score -= 4;
	}

	              c->o[0] = score;

              for(i=0;i<gsize;i++)
              if(relabel[i]==0) newchrom[i] = c->g[i];
                    else newchrom[i] = (1 - c->g[i]);

	            score = 5*gsize/4;

                for(i=0;i<gsize/4;i++)
  {
                   ones = 0;
                   for(j=0;j<4;j++)
                     if(newchrom[4*i+j]==1) ones++;

                     if(ones==0) score -=5;

                       else if (ones==1) score -= 1;
                     else if (ones==2) score -= 2;
                      else if (ones==3) score -= 3;
                      else if (ones==4) score -= 4;
		  }
           c->o[1] = score;

}




int co1(C *c)
{
  int i, j, incs, decs, score1, score2, ones, zeros;

  score1 = score2 = 0;

 /* objective 1 */

    for(i=0;i<gsize;i+=3)
      {
        zeros = 0;
        for(j=0;j<3;j++)
          if(c->g[i+j]==0) zeros++;

        if(zeros==0) score1 +=3;
        else if(zeros==1) score1 +=2;
        else if(zeros==2) score1 +=1;
        else score1+=4;
      }

 /* objective 2 */ 

    for(i=0;i<gsize;i++)
     if(relabel[i]==0) altg[i] = c->g[i];
     else altg[i] = (1 - c->g[i]);


    for(i=0;i<gsize;i+=3)
      {
        zeros = 0;
        for(j=0;j<3;j++)
         if(altg[i+j]==0) zeros++;

         if(zeros==0) score2 +=3;
	   else if(zeros==1) score2 +=2;
	   else if(zeros==2) score2 +=1;
	   else score2+=4;
      }


   c->o[0] = (double)(gsize*2 - score1);
   c->o[1] = (double)(gsize*2 - score2);
}


int co2(C *c)
{
    int i, j, incs, decs, score1, score2, ones, zeros;

      score1 = score2 = 0;

     /* objective 1 */

        for(i=0;i<gsize;i+=5)
	  {
	            zeros = 0;
		            for(j=0;j<5;j++)
			                if(c->g[i+j]==0) zeros++;

		            if(zeros==0) score1 +=5;
		            else if(zeros==1) score1 +=4;
		            else if(zeros==2) score1 +=3;
                            else if(zeros==3) score1 +=2;
                            else if(zeros==4) score1 +=1;
		            else score1+=6;
		  }

     /* objective 2 */

        for(i=0;i<gsize;i++)
	       if(relabel[i]==0) altg[i] = c->g[i];
         else altg[i] = (1 - c->g[i]);


        for(i=0;i<gsize;i+=5)
	  {
	            zeros = 0;
		            for(j=0;j<5;j++)
			               if(altg[i+j]==0) zeros++;


		                                if(zeros==0) score2 +=5;
		                                else if(zeros==1) score2 +=4;
		                                else if(zeros==2) score2 +=3;
		                                else if(zeros==3) score2 +=2;
		                                else if(zeros==4) score2 +=1;
		                                else score2+=6;
		  }


       c->o[0] = (double)(gsize*2 - score1);
       c->o[1] = (double)(gsize*2 - score2);
  }



int f5(C *c)
{

  int i, j, incs, decs, last, _this;

  incs = decs = 0;

 last = c->g[0];

  for(i=1;i<gsize;i++)
    { 
     _this = c->g[i];
     if ((_this-last)==1) incs++;
     else if ((last-_this)==1) decs++;
     last = _this;
   }

 c->o[0] = (double)((gsize-1) - incs);
 c->o[1] = (double)((gsize-1) - decs);
}


int t1(C *c)
{
     double f1, f2, h, g;
     int i, j, k, mul;
     double sum = 0;
     int string[1000];
     double var[30];

     int blocksize = 30;
     int m = 30;


          for (i = 0; i < m; i++)
	            var[i] = 0;

          for (i = 0; i < gsize; i++)
            string[i] = c->g[i];


          for (i = 0; i < m; i++)
	    {
              mul = 1;
              for (k = blocksize-1; k >= 0; k--)
			{
	                      var[i] += mul * string[i*blocksize+k];
                          mul *= 2;
			    }
	}

          for (i = 0; i < m; i++)
	    {
	                  var[i] /= pow(double(2),double(blocksize)) - 1.0;

			}

          for (i = 1; i < m; i++)
	            sum += var[i];


          f1 = var[0];
      

         g = 1 + (9*sum)/(double)(m-1);

         h = 1 - sqrt(double(f1/g));

         f2 = g * h;



         c->o[0] =  f1;
         c->o[1] = f2;

	 /*      printf("XXX %f %f\n", f1,f2); */
   }





int t2(C *c)
{
    // test function T2 described in Eckart Zitzler's PhD thesis. See notes at top for further details
  int i, j;
  int mul;
  double var[30];

  double sum = 0;
  double f1, f2, g, h;

  if ((gsize!=900)||(nalleles!=2)||(nobjs!=2))
    {
      printf("T2 requires 900 binary genes. You have %d genes and they are %d-ary.\nIt is a 2 objective problem. You have %d objectives. Exiting.\n", gsize, nalleles, nobjs);
      exit(-1);
    }

  //set paramaters to zero
  for (i = 0; i < 30; i++)
    var[i] = 0;

  //convert from binary into integer for the 30 params
  for (i = 0; i < 30; i++)
    {
      mul = 1;
      for (j = 29; j >= 0; j--)
        {
          var[i] += mul * c->g[i*30+j];
          mul *= 2;
        }
    }

  // normalize the params between 0 and 1
  for (i = 0; i < 30; i++)
    var[i] /= pow(double(2),double(30));

  f1 = var[0];

  for (i = 1; i < 30; i++)
        sum += var[i];
  g = 1 + (9*sum)/29.0;

  h = 1 - ((f1/g)*(f1/g));

  f2 = g*h;

  c->o[0]=f1;
  c->o[1]=f2;

}


int t3(C *c)
{
    // test function T3 described in Eckart Zitzler's PhD thesis. See notes at top for further details
  int i, j;
  int mul;
  double var[30];

  double sum = 0;
  double f1, f2, g, h;

  if ((gsize!=900)||(nalleles!=2)||(nobjs!=2))
    {
      printf("T3 requires 900 binary genes. You have %d genes and they are %d-ary.\nIt is a 2 objective problem. You have %d objectives. Exiting.\n", gsize, nalleles, nobjs);
      exit(-1);
    }

  //set paramaters to zero
  for (i = 0; i < 30; i++)
    var[i] = 0;

  //convert from binary into integer for the 30 params
  for (i = 0; i < 30; i++)
    {
      mul = 1;
      for (j = 29; j >= 0; j--)
        {
          var[i] += mul * c->g[i*30+j];
          mul *= 2;
        }
    }

  // normalize the params between 0 and 1
  for (i = 0; i < 30; i++)
    var[i] /= pow(double(2),double(30));

  f1 = var[0];

  for (i = 1; i < 30; i++)
        sum += var[i];
  g = 1 + (9*sum)/29.0;

  h = 1 - sqrt(f1/g) - (f1/g)*sin(10*3.141592654*f1);

  f2 = g*h;

  c->o[0]=f1;
  c->o[1]=f2;

}


int t6(C *c)
{
    // test function T6 described in Eckart Zitzler's PhD thesis. See notes at top for further details
  int i, j;
  int mul;
  double var[10];

  double sum = 0;
  double f1, f2, g, h;

  if ((gsize!=300)||(nalleles!=2)||(nobjs!=2))
    {
      printf("T6 requires 300 binary genes. You have %d genes and they are %d-ary.\nIt is a 2 objective problem. You have %d objectives. Exiting.\n", gsize, nalleles, nobjs);
      exit(-1);
    }

  //set paramaters to zero
  for (i = 0; i < 10; i++)
    var[i] = 0;

  //convert from binary into integer for the 10 params
  for (i = 0; i < 10; i++)
    {
      mul = 1;
      for (j = 29; j >= 0; j--)
        {
          var[i] += mul * c->g[i*30+j];
          mul *= 2;
        }
    }

  // normalize the params between 0 and 1
  for (i = 0; i < 10; i++)
    var[i] /= pow(double(2),double(30));

  f1 = 1 - exp(-4*var[0])*pow(double(sin(6*3.141592654*var[0])),double(6));

  for (i = 1; i < 10; i++)
        sum += var[i];
  g = 1 + 9*pow(double(sum/9.0),double(0.25));

  h = 1 - ((f1/g)*(f1/g));

  f2 = g*h;
  

  c->o[0]=f1;
  c->o[1]=f2;

}


int t4(C *c)
{
      double f1, f2, h, g;
          int i, j, k, mul;
          double sum = 0;
          double var[10];

          if ((gsize!=300)||(nalleles!=2)||(nobjs!=2))
	    {
	              printf("T4 requires 300 binary genes. You have %d genes and they are %d-ary.\nIt is a 2 objective problem. You have %d objectives. Exiting.\n", gsize, nalleles, nobjs);
		              exit(-1);
		    }

          //set paramaters to zero
	        for (i = 0; i < 10; i++)
		        var[i] = 0;

          //convert from binary into integer for the 10 params
	        for (i = 0; i < 10; i++)
		  {
		            mul = 1;
			            for (j = 29; j >= 0; j--)
				      {
					            var[i] += mul * c->g[i*30+j];
						                mul *= 2;
						  }
			  }


          for (i = 0; i < 10; i++)
	    {
	              var[i] /= pow(double(2),double(30));
		              if (i)
				{
				              var[i] *= 10;
					                  var[i] -= 5;
					    }
		              //          printf("var[i] = %f\n", var[i]);
		    }


          for (i = 1; i < 10; i++)
	          sum += ((var[i]*var[i])-10 * cos(4 * 3.141592654 * var[i]));

          f1 = var[0];


      //    printf("sum = %f\n", sum);
          g = 1 + 10*(9)+sum;
      //    printf("g = %f\n", g);

          h = 1 - sqrt(f1/g);

          f2 = g * h;

      //    printf("f2 = %f\n", f2);

          c->o[0] = f1;
          c->o[1] = f2;

    }



int t5(C *c)
{
      double f1, f2, h, g;
          int i, j, k, mul;
          double sum = 0;
          const int m = 11;
          double var[m];
          double v[m];

          if ((gsize!=80)||(nalleles!=2)||(nobjs!=2))
	    {
	              printf("T5 requires 80 binary genes. You have %d genes and they are %d-ary.\nIt is a 2 objective problem. You have %d objectives. Exiting.\n", gsize, nalleles, nobjs);
		              exit(-1);
		    }

          for (i = 0; i < m; i++)
	          var[i] = 0;

          for (k = 0; k < 30; k++)
	          var[0] += c->g[k];


          j = 30;

          for (i = 1; i < m; i++)
	    {
	              for (k = 0; k < 5; k++)
			{
			              var[i] += c->g[j];
				                  j++;
				    }
		    }

          sum = 0;
          for (i = 1; i < m; i++)
	    {
	              if (var[i]==5)
			          v[i] = 1;
		              else
				          v[i] = 2 + var[i];
		              sum += v[i];
		    }

          f1 = 1 + var[0];


      //    printf("sum = %f\n", sum);
          g = sum;
      //    printf("g = %f\n", g);

          h = 1.0/f1;

          f2 = g * h;

      //    printf("f2 = %f\n", f2);

          c->o[0] = f1;
          c->o[1] = f2;

    }


int circles(C *c)
{
  double f1, f2, h, g, R, O;
  double mul;
  int i, j, k;
  double sum = 0;
  double var[2];
  
  if ((gsize!=80)||(nalleles!=2)||(nobjs!=2))
    {
      printf("cir requires 80 binary genes. You have %d genes and they are %d-ary.\nIt is a 2 objective problem. You have %d objectives. Exiting.\n", gsize, nalleles, nobjs);
      exit(-1);
    }
  
  //set paramaters to zero
  for (i = 0; i < 2; i++)
    var[i] = 0;
  
  //convert from binary into integer for the 10 params
  for (i = 0; i < 2; i++)
    {
      mul = 1.0;
      for (j = 39; j >= 0; j--)
	{
	  var[i] += mul * c->g[i*40+j];
	  mul *= 2;
	}
    }
  
  
  for (i = 0; i < 2; i++)
    {
      var[i] /= pow(double(2),double(40))+1;
    }
  
 
  
  R = 0.01 + 0.99*pow(double(var[1]),double(0.1));
  
  f1 = (1-R) + R*sin(var[0]*3.141592654*0.5);
  
  f2 = (1-R) + R*cos(var[0]*3.141592654*0.5);
  
  //    printf("f2 = %f\n", f2);
  
  c->o[0] = 99+f1;
  c->o[1] = 99+f2;

}

void sphere(C *c)
{
  double f1, f2, f3, h, g, R, O;
  double mul;
  int i, j, k;
  double sum = 0;
  double var[3];
  
  if ((gsize!=90)||(nalleles!=2)||(nobjs!=3))
    {
      printf("cir requires 90 binary genes. You have %d genes and they are %d-ary.\nIt is a 2 objective problem. You have %d objectives. Exiting.\n", gsize, nalleles, nobjs);
      exit(-1);
    }
  
  //set paramaters to zero
  for (i = 0; i < 3; i++)
    var[i] = 0;
  
  //convert from binary into integer for the 10 params
  for (i = 0; i < 3; i++)
    {
      mul = 1.0;
      for (j = 29; j >= 0; j--)
	{
	  var[i] += mul * c->g[i*30+j];
	  mul *= 2;
	}
    }
  
  
  for (i = 0; i < 3; i++)
    {
      var[i] /= pow(double(2),double(30))+1;
    }
  
 
  
  R = 0.01 + 0.99*pow(double(var[2]),double(0.1));
  
  f1 = (1-R) + R*cos(var[0]*3.141592654*0.5)*cos(var[1]*3.141592654*0.5);
  
  f2 = (1-R) + R*cos(var[0]*3.141592654*0.5)*sin(var[1]*3.141592654*0.5);

  f3 = (1-R) + R*sin(var[0]*3.141592654*0.5);

  // fprintf(stderr,"v0=%lf  v1=%lf  v2=%lf\n", var[0], var[1], var[2]);
  // fprintf(stderr,"f1=%lf  f2=%lf  f3=%lf\n", f1, f2, f3);
  
  c->o[0] = 99+f1;
  c->o[1] = 99+f2;
  c->o[2] = 99+f3;

}






int copy_chromosome(C *from, C *to)
{
 int i;

 to->num = from->num;

 for(i=0;i<gsize;i++) {
   to->g[i] = from->g[i];
   to->rank[i] = from->rank[i];
 }


 for(i=0;i<nobjs;i++)
   to->o[i] = from->o[i];
  
   to->strength = from->strength;
}



/* c is a chromosome in ep. How many doe sit cover in ip ? */  
int ncoverinip(C *c)
{
  int i, j, r;
  
  r = 0;

  for(i=0;i<ipsize;i++)
   if (covers(c,&ip[i])) r++;

 return(r);
}
    
int reproduce()
{
  int i, j, n, worst;
  C *p1, *p2, *p3; 
 
 n=0;

 if(selmeth==2) update_occboxes();


  while (n<ipsize)
    {
      //      cout << n << endl;
       if(selmeth==1) {   
            p1 = select1();
            p2 = select1();
	  }
       else {
             p1 = select2();
             p2 = select2();
	   }

       if((curepsize>1) && (selmeth==1)) {

	   while (p2==p1)  p2 = select1();
       }


            copy_chromosome(p1,&mp[n]);
            copy_chromosome(p2,&mp[n+1]);
  
	    if (mydrand()<cross_rate)
        {
	  // cerr << "Crossover" << endl;
	  naive(n);
        }
	      mutate(n); 


      n+=2;
    }

 for(i=0;i<ipsize;i++)
  {
   evaluate(&mp[i]);
   copy_chromosome(&mp[i], &ip[i]); 
   }



}


int update_occboxes()
{
 int i, j;
 int p;

 p = (int)(pow(double(grid),double(nobjs)));

 for(i=0;i<p;i++)  occboxes[i] = 0;
 noccboxes = 0;

 for(i=0;i<p;i++)
  if(boxcount[i]>0) occboxes[noccboxes++]=i;

}


int worstinip()
{
  double w;
  int i, wi;

  w = 0.0;

  for(i=0;i<ipsize;i++)
   if(ip[i].strength>w) { wi = i; w = ip[i].strength; }

  return(wi);
}

int ind_strength(C *c)
{
  int i;

  c->strength=1;
 
  for(i=0;i<curepsize;i++)
    if(covers(&ep[i],c)) c->strength += ep[i].strength;
}
  
void print_genotype(int *gen, int len)
{
    int i;
    for(i=0;i<len;i++)
      {
	printf("%d ",gen[i]);
      }
    printf("\n");
}



void naive(int n)
{
  // a naive two-point crossover

  int tmp;
  int tmp2;
  C *m;
  m=&mp[n];

  // uniform
  for(int i=0;i<gsize;i++)
    {
      if(mydrand()<0.5)
        {
          tmp=m[0].g[i];
	  tmp2 = m[0].rank[i];
          m[0].g[i]=m[1].g[i];
	  m[0].rank[i]=m[1].rank[i];
          m[1].g[i]=tmp;
	  m[1].rank[i]=tmp2;
        }
    }
  
  //  two-point
  /*  int cp1,cp2;
  cp1 = myrand(gsize);
  cp2 = (cp1+myrand(gsize-1))%gsize;
  for(int i=cp1;i!=cp2;i=(i+1)%gsize)
    {
      tmp=m[0].g[i];
      tmp2 = m[0].rank[i];
      m[0].g[i]=m[1].g[i];
      m[0].rank[i]=m[1].rank[i];
      m[1].g[i]=tmp;
      m[1].rank[i]=tmp2;
    }      
  */
}



  
  /* mutate chromosome c */
int mutate(int n)
{

  int i;
  //  C *m1, *m2;
  C *m;
  m=&(mp[n]);
  //  m1 = &(mp[n]);
  //  m2 = &(mp[n+1]);

 
    for(i=0;i<gsize;i++) {
      //    cerr << bin->precomputed_d(i,m[0].g[i]) << endl;
      if (mydrand() < mute_rate+square(double(m[0].rank[i])/double(gsize))) {
	int index = myrand(L);
	//	cerr << i << " " <<  m[0].rank[i] << " " <<  index << endl;
	m[0].g[i] = neighbours[i][index];
	m[0].rank[i] = index;
      }
    }
 
 
    for(i=0;i<gsize;i++) {
      if (mydrand()< mute_rate+square(double(m[1].rank[i])/double(gsize))) {
	int index = myrand(L);
	//	cerr << i << " " << m[1].rank[i] << " " << index <<  endl;
	m[1].g[i] = neighbours[i][index];
	m[1].rank[i] = index;
      }
    }




  
  
}


/* select something from either ip or ep */

C *select1()
{
  int c, d; 
  double cs, ds;
  C *r;
  
  
  
  if(mydrand()<psep) {
      if (curepsize > 1) {
	  c = myrand(curepsize);
	  d = myrand(curepsize);
	  
	  cs = boxcount[ep[c].bn];
	  ds = boxcount[ep[d].bn];
	  
	  if (cs<ds)
	      r = &ep[c];
	  else 
	      r = &ep[d];
      }
      else r = &ep[0];
  }


  else {
      
      r = &ip[myrand(ipsize)];
  }
  
 return(r);
}


C *select2()
{
  int i, c, d, choose;
  double cs, ds, p;

  C *r;
  C *p1;
  C *p2;


 if(mydrand()<psep) {


   if (noccboxes > 1) {
     c = myrand(noccboxes);
     d = myrand(noccboxes);

     cs = boxcount[occboxes[c]];
     ds = boxcount[occboxes[d]];

     if (cs<ds)
       choose = occboxes[c];
     else choose = occboxes[d];
   }
   else choose = occboxes[0];

     /* now get a chromosome from that box */


  if (curepsize > 1) {
      c = myrand(curepsize);
 
      for(i=0;i<curepsize;i++)
      { if(ep[(c%curepsize)].bn==choose) break;
      else c++;
      }
   
      r = &ep[c%curepsize];
  }
  else {
      r = &ep[0];
  }


 }


 else {

 
 p1 = &ip[myrand(ipsize)];
 do
p2 =  &ip[myrand(ipsize)];
while(p2==p1);
 if(p1->o[0]<p2->o[0])
r=p1; 
else 
r=p2;



 }

 return(r);
}

 
int myrand(int n)
{
  return (int) floor(ran0(&seed)*n);
  //return (int)( abs(rrandom())%n);
}

double mydrand()
{
  return ran0(&seed);
  //  return (double) (myrand(1000000))/1000000.0;
}
 

  
/*
 * Copyright (c) 1983 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

#if defined(LIBC_SCCS) && !defined(lint)
static char sccsid[]= "@(#)random.c    5.5 (Berkeley) 7/6/88";
#endif				/* LIBC_SCCS and not lint */

/* ANSIfied by PMR 17 May 95 */


/*
 * random.c:
 * An improved random number generation package.  In addition to the standard
 * rand()/srand() like interface, this package also has a special state info
 * interface.  The initstate2() routine is called with a seed, an array of
 * bytes, and a count of how many bytes are being passed in; this array is then
 * initialized to contain information for random number generation with that
 * much state information.  Good sizes for the amount of state information are
 * 32, 64, 128, and 256 bytes.  The state can be switched by calling the
 * setstate2() routine with the same array as was initiallized with initstate2().
 * By default, the package runs with 128 bytes of state information and
 * generates far better random numbers than a linear congruential generator.
 * If the amount of state information is less than 32 bytes, a simple linear
 * congruential R.N.G. is used.
 * Internally, the state information is treated as an array of longs; the
 * zeroeth element of the array is the type of R.N.G. being used (small
 * integer); the remainder of the array is the state information for the
 * R.N.G.  Thus, 32 bytes of state information will give 7 longs worth of
 * state information, which will allow a degree seven polynomial.  (Note: the
 * zeroeth word of state information also has some other information stored
 * in it -- see setstate2() for details).
 * The random number generation technique is a linear feedback shift register
 * approach, employing trinomials (since there are fewer terms to sum up that
 * way).  In this approach, the least significant bit of all the numbers in
 * the state table will act as a linear feedback shift register, and will have
 * period 2^deg - 1 (where deg is the degree of the polynomial being used,
 * assuming that the polynomial is irreducible and primitive).  The higher
 * order bits will have longer periods, since their values are also influenced
 * by pseudo-random carries out of the lower bits.  The total period of the
 * generator is approximately deg*(2**deg - 1); thus doubling the amount of
 * state information has a vast influence on the period of the generator.
 * Note: the deg*(2**deg - 1) is an approximation only good for large deg,
 * when the period of the shift register is the dominant factor.  With deg
 * equal to seven, the period is actually much longer than the 7*(2**7 - 1)
 * predicted by this formula.
 */



/*
 * For each of the currently supported random number generators, we have a
 * break value on the amount of state information (you need at least this
 * many bytes of state info to support this random number generator), a degree
 * for the polynomial (actually a trinomial) that the R.N.G. is based on, and
 * the separation between the two lower order coefficients of the trinomial.
 */

#define         TYPE_0          0	/* linear congruential */
#define         BREAK_0         8
#define         DEG_0           0
#define         SEP_0           0

#define         TYPE_1          1	/* x**7 + x**3 + 1 */
#define         BREAK_1         32
#define         DEG_1           7
#define         SEP_1           3

#define         TYPE_2          2	/* x**15 + x + 1 */
#define         BREAK_2         64
#define         DEG_2           15
#define         SEP_2           1

#define         TYPE_3          3	/* x**31 + x**3 + 1 */
#define         BREAK_3         128
#define         DEG_3           31
#define         SEP_3           3

#define         TYPE_4          4	/* x**63 + x + 1 */
#define         BREAK_4         256
#define         DEG_4           63
#define         SEP_4           1


/*
 * Array versions of the above information to make code run faster -- relies
 * on fact that TYPE_i == i.
 */

#define         MAX_TYPES       5	/* max number of types above */

static int degrees[MAX_TYPES] =
{DEG_0, DEG_1, DEG_2,
 DEG_3, DEG_4};

static int seps[MAX_TYPES] =
{SEP_0, SEP_1, SEP_2,
 SEP_3, SEP_4};



/*
 * Initially, everything is set up as if from :
 *              initstate2( 1, &randtbl, 128 );
 * Note that this initialization takes advantage of the fact that julias_srandom()
 * advances the front and rear pointers 10*rand_deg times, and hence the
 * rear pointer which starts at 0 will also end up at zero; thus the zeroeth
 * element of the state information, which contains info about the current
 * position of the rear pointer is just
 *      MAX_TYPES*(rptr - state) + TYPE_3 == TYPE_3.
 */

static long randtbl[DEG_3 + 1] =
{TYPE_3,
 0x9a319039, 0x32d9c024, 0x9b663182, 0x5da1f342,
 0xde3b81e0, 0xdf0a6fb5, 0xf103bc02, 0x48f340fb,
 0x7449e56b, 0xbeb1dbb0, 0xab5c5918, 0x946554fd,
 0x8c2e680f, 0xeb3d799f, 0xb11ee0b7, 0x2d436b86,
 0xda672e2a, 0x1588ca88, 0xe369735d, 0x904f35f7,
 0xd7158fd6, 0x6fa6f051, 0x616e6b96, 0xac94efdc,
 0x36413f93, 0xc622c298, 0xf5a42ab8, 0x8a88d77b,
 0xf5ad9d0e, 0x8999220b, 0x27fb47b9};

long *rng_tbl = &randtbl[0];
 
/*
 * fptr and rptr are two pointers into the state info, a front and a rear
 * pointer.  These two pointers are always rand_sep places aparts, as they cycle
 * cyclically through the state information.  (Yes, this does mean we could get
 * away with just one pointer, but the code for random() is more efficient this
 * way).  The pointers are left positioned as they would be from the call
 *                      initstate2( 1, randtbl, 128 )
 * (The position of the rear pointer, rptr, is really 0 (as explained above
 * in the initialization of randtbl) because the state table pointer is set
 * to point to randtbl[1] (as explained below).
 */

static long *fptr = &randtbl[SEP_3 + 1];
static long *rptr = &randtbl[1];



/*
 * The following things are the pointer to the state information table,
 * the type of the current generator, the degree of the current polynomial
 * being used, and the separation between the two pointers.
 * Note that for efficiency of random(), we remember the first location of
 * the state information, not the zeroeth.  Hence it is valid to access
 * state[-1], which is used to store the type of the R.N.G.
 * Also, we remember the last location, since this is more efficient than
 * indexing every time to find the address of the last element to see if
 * the front and rear pointers have wrapped.
 */

static long *state = &randtbl[1];

static int rand_type = TYPE_3;
static int rand_deg = DEG_3;
static int rand_sep = SEP_3;

static long *end_ptr = &randtbl[DEG_3 + 1];



/*
 * julias_srandom:
 * Initialize the random number generator based on the given seed.  If the
 * type is the trivial no-state-information type, just remember the seed.
 * Otherwise, initializes state[] based on the given "seed" via a linear
 * congruential generator.  Then, the pointers are set to known locations
 * that are exactly rand_sep places apart.  Lastly, it cycles the state
 * information a given number of times to get rid of any initial dependencies
 * introduced by the L.C.R.N.G.
 * Note that the initialization of randtbl[] for default usage relies on
 * values produced by this routine.
 */

void julias_srandom(unsigned x)
{
  register int i, j;
  long rrandom();

  if (rand_type == TYPE_0) {
    state[0] = x;
  } else {
    j = 1;
    state[0] = x;
    for (i = 1; i < rand_deg; i++) {
      state[i] = 1103515245 * state[i - 1] + 12345;
    }
    fptr = &state[rand_sep];
    rptr = &state[0];
    for (i = 0; i < 10 * rand_deg; i++)
      rrandom();
  }
}



/*
 * initstate2:
 * Initialize the state information in the given array of n bytes for
 * future random number generation.  Based on the number of bytes we
 * are given, and the break values for the different R.N.G.'s, we choose
 * the best (largest) one we can and set things up for it.  julias_srandom() is
 * then called to initialize the state information.
 * Note that on return from julias_srandom(), we set state[-1] to be the type
 * multiplexed with the current value of the rear pointer; this is so
 * successive calls to initstate2() won't lose this information and will
 * be able to restart with setstate2().
 * Note: the first thing we do is save the current state, if any, just like
 * setstate2() so that it doesn't matter when initstate2 is called.
 * Returns a pointer to the old state.
 */

char *
 initstate2(
		unsigned seed,	/* seed for R. N. G. */
		char *arg_state,/* pointer to state array */
		int n		/* # bytes of state info */
)
{
  register char *ostate = (char *) (&state[-1]);

  if (rand_type == TYPE_0)
    state[-1] = rand_type;
  else
    state[-1] = MAX_TYPES * (rptr - state) + rand_type;
  if (n < BREAK_1) {
    if (n < BREAK_0) {
      fprintf(stderr, "initstate2: not enough state (%d bytes) with which to do jack; ignored.\n", n);
      return NULL;
    }
    rand_type = TYPE_0;
    rand_deg = DEG_0;
    rand_sep = SEP_0;
  } else {
    if (n < BREAK_2) {
      rand_type = TYPE_1;
      rand_deg = DEG_1;
      rand_sep = SEP_1;
    } else {
      if (n < BREAK_3) {
	rand_type = TYPE_2;
	rand_deg = DEG_2;
	rand_sep = SEP_2;
      } else {
	if (n < BREAK_4) {
	  rand_type = TYPE_3;
	  rand_deg = DEG_3;
	  rand_sep = SEP_3;
	} else {
	  rand_type = TYPE_4;
	  rand_deg = DEG_4;
	  rand_sep = SEP_4;
	}
      }
    }
  }
  state = &(((long *) arg_state)[1]);	/* first location */
  end_ptr = &state[rand_deg];	/* must set end_ptr before julias_srandom */
  julias_srandom(seed);
  if (rand_type == TYPE_0)
    state[-1] = rand_type;
  else
    state[-1] = MAX_TYPES * (rptr - state) + rand_type;
  return (ostate);
}



/*
 * setstate2:
 * Restore the state from the given state array.
 * Note: it is important that we also remember the locations of the pointers
 * in the current state information, and restore the locations of the pointers
 * from the old state information.  This is done by multiplexing the pointer
 * location into the zeroeth word of the state information.
 * Note that due to the order in which things are done, it is OK to call
 * setstate2() with the same state as the current state.
 * Returns a pointer to the old state information.
 */

char *
 setstate2(char *arg_state)
{
  register long *new_state = (long *) arg_state;
  register int type = new_state[0] % MAX_TYPES;
  register int rear = new_state[0] / MAX_TYPES;
  char *ostate = (char *) (&state[-1]);

  if (rand_type == TYPE_0)
    state[-1] = rand_type;
  else
    state[-1] = MAX_TYPES * (rptr - state) + rand_type;
  switch (type) {
  case TYPE_0:
  case TYPE_1:
  case TYPE_2:
  case TYPE_3:
  case TYPE_4:
    rand_type = type;
    rand_deg = degrees[type];
    rand_sep = seps[type];
    break;

  default:
    fprintf(stderr, "setstate2: state info has been munged; not changed.\n");
  }
  state = &new_state[1];
  if (rand_type != TYPE_0) {
    rptr = &state[rear];
    fptr = &state[(rear + rand_sep) % rand_deg];
  }
  end_ptr = &state[rand_deg];	/* set end_ptr too */
  return (ostate);
}



/*
 * random:
 * If we are using the trivial TYPE_0 R.N.G., just do the old linear
 * congruential bit.  Otherwise, we do our fancy trinomial stuff, which is the
 * same in all ther other cases due to all the global variables that have been
 * set up.  The basic operation is to add the number at the rear pointer into
 * the one at the front pointer.  Then both pointers are advanced to the next
 * location cyclically in the table.  The value returned is the sum generated,
 * reduced to 31 bits by throwing away the "least random" low bit.
 * Note: the code takes advantage of the fact that both the front and
 * rear pointers can't wrap on the same call by not testing the rear
 * pointer if the front one has wrapped.
 * Returns a 31-bit random number.
 */

long int rrandom(void)
{
  long i;

  if (rand_type == TYPE_0) {
    i = state[0] = (state[0] * 1103515245 + 12345) & 0x7fffffff;
  } else {

    /* Original version had:                                             */
    /*  *fptr += *rptr;                                                  */
    /*  i = (*fptr >> 1) & 0x7fffffff;      /* chucking least random bit */
    /* now replaced by the following four lines so that fptr gets updated*/
    /* by adding the right-shifted rear value. Thanks to Felix Wyss for  */
    /* this.                                                             */
    *fptr += *rptr >> 1;
    if(*rptr & 0x00000001)
      *rptr += 0x80000000;
    i = (*fptr);
    if (++fptr >= end_ptr) {
      fptr = state;
      ++rptr;
    } else {
      if (++rptr >= end_ptr)
	rptr = state;
    }
  }
  return (i);
}

   
/* end of rand includes */

/*

// Below is a set of four test functions (f2-f5) which are for use in testing multiobjective
// optimisers. Each function takes an integer chromosome (chrom), a double evaluation vector (eval), and
// an integer specifying the number of genes there are in the chromosome (genes). 

// Joshua Knowles 1999.
*/

int f2(C *c);
int f3(C *c);
int f4(C *c);
int ff5(C *c);
int correl(C *c);

int f2(C *c)
{
    // This is Schaffer's f2 function.
    // The function takes a binary encoded chromosome and converts it to a real value which lies
    // on the x-coordinate. The evaluations of each of the two objectives are then calculated.
    // The first objective is x squared. The second is (x-2) squared. 
    // The range and offset of x are hard coded into the function. (range = 12, offset = -6).

    static double sum = 0;
    int i;
    double val;
    double num;
    double x;
    double div, range;
    val = 1.0;
    num = 0.0;
    range = 12;  // the range of values the x co-ordinate spans over

    for (i = gsize-1; i >= 0; i--)
	{
	    if(c->g[i])
		num+=val;
	    val *=2;
	}

    div = (pow(double(2), double(gsize)))/range;
    x = num/div;
    x -= 6.0;   // offset of the x co-ordinate 
   
    c->o[0] = x*x;
    c->o[1] = (x-2)*(x-2);
     
}

/* CARRY ON FROM HERE */
int f3(C* c)
{
    // This is Schaffer's f3 function.
    // The function takes a binary encoded chromosome and converts it to a real value which lies
    // on the x-coordinate. The evaluations of each of the two objectives are then calculated.
    // The first objective is a piece-wise linear function. The second is (x-5) squared. 
    // The range and offset of x are hard coded into the function. (range = 10, offset = -2).


    static double sum = 0;
    int i;
    double val;
    double num;
    double x;
    double div, range;
    val = 1.0;
    num = 0.0;
    range = 10;

    for (i = gsize-1; i >= 0; i--)
	{
	    if(c->g[i])
		num+=val;
	    val *=2;
	}

    div = (pow(double(2), double(gsize)))/range;
    x = num/div;
    x -= 2.0;
   
 
    if (x <= 1.0)
	c->o[0] = -x;
    else if ((x>1.0)&&(x<=3.0))
	c->o[0] = -2.0+x;
    else if ((x>3.0)&&(x<=4.0))
	c->o[0] = 4.0-x;
    else
	c->o[0] = -4.0+x;

    c->o[1] = (x-5.0)*(x-5.0);
}    

int f4(C *c)
{
    
    // This is Fonseca's f1 function.
    // It takes a binary chromosome and converts it into two real values, x1 and x2. 
    // Each of the two objective evaluations are then calculated from the values of x1 and x2.
    // The ranges and offsets of x1 and x2 are hard coded into the function. (range = 4, offset =-2).
    
    static double sum = 0;
    int i;
    double val;
    double num;
    double x1, x2;
    double x1div, x1range;
    double x2div, x2range;
    val = 1.0;
    num = 0.0;
    x1range = 4.0;
    x2range = 4.0;

    for (i = gsize-1; i >= gsize/2; i--)
	{
	    if(c->g[i])
		num+=val;
	    val *=2;
	}
   
    x1div = (pow(double(2), double(gsize/2)))/x1range;
    x1 = num/x1div;
    x1 -= 2.0;
   
    num = 0.0;
    val = 1.0;
    for (i = (gsize/2)-1; i >= 0; i--)
	{
	    if(c->g[i])
		num+=val;
	    val *= 2;
	}
    x2div = (pow(double(2), double(gsize/2)))/x2range;
    x2 = num/x2div;
    x2 -= 2.0;

    c->o[0] = 1.0 - exp(-((x1-1)*(x1-1)) - ((x2+1)*(x2+1)));
    c->o[1] = 1.0 - exp(-((x1+1)*(x1+1)) - ((x2-1)*(x2-1)));

}

int ff5(C *c)
{

    // This is Knowles and Corne's f5 - the k optima function.
    // A k-ary chromosome of length k is taken as input.
    // Objective 1 reads the chromosome from left to right and counts 
    // the number of adjacent genes which are consecutive increases of 1.
    // Objective 2 reads the chromosome from left to right and counts 
    // the number of adjacent genes which are consecutive decreases of 1.
    // However, the function is to be minimised so the objectives above are subtracted from 
    // the initial chromosome length, k, -1.

    int i;
    c->o[0] = gsize-1;
    c->o[1] = gsize-1;

    for (i = 0; i < gsize-1; i++)
	{
	    if(c->g[i+1]==c->g[i]+1)
		c->o[0]--;
	    
	    if(c->g[i+1]==c->g[i]-1)
		c->o[1]--;
	}
}

int correl(C *c)
{
  //gsize should be 48; 6 variables of 

  double var[6];
  int i,j,k;
  int mul;

  for(i=0;i<6;i++)
    {
      var[i]=0.0;
    }

  mul=1;
  for (i = 0; i < gsize; i++)
    {
      var[i/8]+=c->g[i]*mul;
      mul*=2;
      if(i%6==0)
	mul=1;
    }
  for(i=0;i<6;i++)
    {
      var[i]/=127.0;
    }

  c->o[0] = 99.0 + var[0]*var[1]*var[2]*var[3]-var[4]*var[5];
  c->o[1] = 99.0 + var[1]*var[2]*var[3]*var[4]-var[5]*var[0];
  c->o[2] = 99.0 + var[2]*var[3]*var[4]*var[5]-var[0]*var[1];
  
}



// **********************************************************************//
// This is the Adaptive Distributed Database Management Problem (ADDMP). //
// It can be used as a multiobjective function for testing multiobjective//
// optimizers. This file contains several functions for decoding and     //
// evaluating a solution. However, a call to the function addmp is all   //
// that is required to evaluate a solution. The function takes a         //
// 10-ary integer chromosome of length 10 and an evaluation vector of    //
// type double.                                                          //
//                                                                       //
// The particular configuration of the distributed database is stored in //
// a file called scA, which must be placed in the same directory as this //
// code.                                                                 //
//                                                                       //
// The actual meaning of the two objectives are the mean response time   //
// and worst response time as seen by a user.                            //
//                                                                       //
// **********************************************************************//


/* NECESSARY DEFS AND VARIABLES */

#define GDTRUE 1
#define GDFALSE 0

int nodes;                  /* number of nodes in the comms network */
double *btt;                /* array of base transaction times in ms */
double *crt;                       /* client retrieval rates */
double *cur;                       /* client update rates */
double *col;                       /* client overlaps */
double *bcomms;                    /* base comms table */
double *otr;                 /* overall transaction rate per client */
double *acomms;                 /* active comms table */
double *cod;                    /* communication overhead delays */
double scr;                     /* server contention rate */
double mrr;                     /* maximum retrieval rate */
int biggest_allele;

char datafilename[50];



int addmp(C *c)
{
  FILE *f;
  int i;
  static int j = 0;
  double first, second;

 /* to initialise, you need to read the data file "scA" as follows, 
which puts info into all those variables up there */

  if(!j)
      read_adb_data();

 eval_adb(c);
  if (c->o[0]>100)
        
	 c->o[0] = 100.0;
      

  j++;
}



/***************************************************************/
/* Get the next number from the input: put it in the location  */
/* addressed by second argument. This function returns 0 on    */
/* EOF. If stopateol is true, it returns -1 when it hits \n    */
/* (after which some other procedure has to read past the \n), */
/* otherwise it continues looking for the next number.         */
/* A number has an optional sign, perhaps followed by digits,  */
/* perhaps followed by a decimal point, perhaps followed by    */
/* more digits. There must be a digit somewhere for it to count*/
/* as a number. So it would read any of:                       */
/*  -.5                                                        */
/*  -0.5                                                       */
/*  -.5.7                                                      */
/* as minus-a-half. In the last case, it would read .7 next    */
/* time around.                                                */
/*   There doesn't seem to be a neat and reliable way to do    */
/* all this, including stopateol, using scanf?                 */
/***************************************************************/

double getdouble(FILE * file, double *valaddr, int stopateol)

{
  int c;
  int found = GDFALSE, indecimal = GDFALSE;
  int sign = +1;
  double n = 0.0, p = 1.0;

  /* First find what looks like start of a number - the first digit. */
  /* And note any sign and whether we just passed a decimal point.   */
  do {
    c = fgetc(file);
    if (c == EOF)
      return (0);
    else if (stopateol && c == '\n')
      return (-1);
    else if (c == '+' || c == '-') {
      sign = (c == '+') ? +1 : -1;
      c = fgetc(file);
      if (c == EOF)
	return (0);
      else if (stopateol && c == '\n')
	return (-1);
    }
    if (c == '.') {
      indecimal = GDTRUE;
      c = fgetc(file);
      if (c == EOF)
	return (0);
      else if (stopateol && c == '\n')
	return (-1);
    }    if (c >= '0' && c <= '9') {
      found = GDTRUE;
    } else {
      sign = +1;
      indecimal = GDFALSE;
    }
  } while (!found);

  /* Now we've got digit(s) ... */
  do {
    n = 10.0 * n + c - '0';
    p = 10.0 * p;
    c = fgetc(file);

    if ((c < '0') || (c > '9')) {
      found = GDFALSE;
      /* We've run out. If we already saw a decimal point, return now */
      if (indecimal) {
	if (c != EOF)
	  ungetc(c, file);
	*valaddr = sign * n / p;
	return (1);
      } else
	p = 1.0;
    }
  } while (found);

  /* We ran out and we didn't see a decimal point, so is this a decimal? */
  if (c != '.') {
    /* No, give it back to caller */
    if (c != EOF)
      ungetc(c, file);
    *valaddr = sign * n;
    return (1);
  } else {
    /* It is. Step past it, carry on hoping for more digits */
    c = fgetc(file);
    while (c >= '0' && c <= '9') {
      n = 10.0 * n + c - '0';
      p = p * 10.0;
      c = fgetc(file);
    }
    /* We've run out of digits but we have a number to give */
    if (c != EOF)
      ungetc(c, file);
    *valaddr = sign * n / p;
    return (1);
  }
}

/* Use getdouble() above but convert result to int. */
int getint(FILE * f, int *valaddr, int stopateol)
{
  int r;
  double x;
  r = (int)getdouble(f, &x, stopateol);
  *valaddr = (int) x;
  return (r);
}


/* For adaptive database problem */
int read_adb_data(void)
{
   FILE *f;
   int i,j;
   long t;
   double in;

   /* read basic details of number of nodes */

 if ((f = fopen("scA", "r")) != (FILE *) NULL) {
   getint(f,&nodes,GDFALSE);}
 else {fprintf(stderr, "can't open data file\n"); exit(0);}
     
  /* there are nodes nodes -- collect the base transaction times */

  btt = (double *)malloc(nodes*sizeof(double));

 for(i=0;i<nodes;i++)
   {getdouble(f,&in,GDFALSE); btt[i]=in;
   }

  /* collect retrieval, update rates, and overlaps per client */
 
 crt =  (double *)malloc(nodes*sizeof(double));
 cur =  (double *)malloc(nodes*sizeof(double));
 col =  (double *)malloc(nodes*sizeof(double));


  for(i=0;i<nodes;i++)
    {getdouble(f,&in,GDFALSE); crt[i]=in;
     getdouble(f,&in,GDFALSE); cur[i]=in;
     getdouble(f,&in,GDFALSE); col[i]=in;
   }

  /* now for the base comms table */

 bcomms = (double *)malloc(nodes*nodes*sizeof(double));

 for(i=0;i<nodes;i++)
  for(j=0;j<nodes;j++)
    {getdouble(f,&in,GDFALSE); bcomms[nodes*i + j]=in;}

 /* finally, get the server contention rate */

  getdouble(f,&scr,GDFALSE);

  fclose(f);

  getdouble(f,&mrr, GDFALSE);

  /* do some book-keeping and set up arrays to be used in evaluation */

  otr = (double *) malloc(nodes*sizeof(double));
  acomms = (double *) malloc(nodes*nodes*sizeof(double));
  cod = (double *) malloc(nodes*nodes*sizeof(double));
      
  biggest_allele = nodes-1;
 }


double eval_adb(C *c)
{
    int i,j, nservers, serv[100];
    double respr, tserv[100], worst, htr, str, ttr;

			      
  /* calculate overall transaction rate per client */
  
  /* otr[i] will hold the overall transaction rate of client i */
 /*  ctr[i]  ... retrieval rate */
 /*  cur[i] ...  update rate */
 /*  I interpreted this formula:

 Overall Transaction Rate =( ( Sum of transaction rates - highest
 transaction rate ) * resource contention value ) + highest transaction rate

   as follows:

 sum of transaction rates for i is just sum of its Retrieval and Update Rates.
 So, the formula reduces to:

   OTR =  minimum of (retrieval rate, update rate) * overlap 
          + maximum of (retrieval rate,update rate)
 
 */	  

 for(i=0;i<nodes;i++)
  otr[i] = (double)(mmin(crt[i],cur[i])*col[i]) + (double)(mmax(crt[i],cur[i]));


  /* sa 106 -- 10^-3  for 1000, cr = 0.9795 5000 0.9959 */

  /* Now populating the array L (called acomms) with the update rate 
    for each client. Eg: acomms[i][j] refers to client i and server j
    (note acomms[i][j] is equivalent to acomms[nodes*i+j])
    so acomms[i][j] will now contain the update rate for client i, for every j */

 for(i=0;i<nodes;i++)
  for(j=0;j<nodes;j++)
    acomms[nodes*i+j] = (double)(cur[i]);

 /* now we want acomms[i][j] to be the overall transaction rate for i, in just
  those cases where the solution connects i to server j. 

  In other cases, acomms[i][j] remains being the update rate for client i. 

  ( the solution vector is genotype, so that genotype[i] gives the server connected
   to by client i. */

 for(i=0;i<nodes;i++)
  acomms[nodes*i + c->g[i]] = otr[i];

    
 /* now effective communication overhead delays: not too sure about this bit 
  
   cod[i][j] is the comms overhead delay for client i and server j.

  I make  cod[i][j] =   Response Time (formula {1})

                    =   1/ (1/btt[i][j] - acomms[i][j] )


 In the below `respr' is  1/btt - tar . I check this isn't zero before
 reciprocating it */

 for(i=0;i<nodes;i++)
   for(j=0;j<nodes;j++)
     { respr = 1.0/bcomms[i*nodes+j] - acomms[nodes*i + j];
      if(respr<0.0001) respr=0.000000001;
      cod[nodes*i + j] =  1.0/respr;
     }

    
 /* Now -- to actually work out the over */

 /* Find those being used as servers */

  for(i=0;i<nodes;i++) serv[i]=0;
  for(i=0;i<nodes;i++) serv[c->g[i]]=1;
  nservers=0; for(i=0;i<nodes;i++) if (serv[i]==1) nservers++;


 /* the array tserv[i] will add up all the transaction rates being processed on 
   server i */

  for(i=0;i<nodes;i++) /* for each server */
   /* if(serv[i]==1)  */

      { /* work out the sum of trans rates on it, and highest */
        str=0.0; htr=0.0; 
        for(j=0;j<nodes;j++){
             ttr = acomms[nodes*j+i];
             str+=ttr;
             if(ttr>htr) htr=ttr;
	   }
        /* now work out the overall transaction rate using {2} */

       tserv[i] = (str-htr)*scr + htr;
 
  /* now use this as the transaction rate in formula {1} */

      respr =  1.0/btt[i] - tserv[i];
      if(respr<0.0001) respr = 0.000000001;

   tserv[i] = 1.0/respr;
      }



    
/* now, for each server, find the client in cod with worst time, and add to tserv */

   for(i=0;i<nodes;i++)
       /* if(serv[i]==1) */
      { 
         /* find worst client */
        htr=0.0;
        for(j=0;j<nodes;j++)
          if(cod[j*nodes+i]>htr) htr=cod[j*nodes+i];
        tserv[i]+=htr;
      }



      
  /* now find least worst + average of the remainder */

     worst=0.0; htr=0.0;
     for(i=0;i<nodes;i++)
        {if(tserv[i]>worst) worst=tserv[i];
         htr+=tserv[i];
       }

    htr-=worst;
    htr /= (double)(nodes-1) ;
    /* htr*=0.1; */


/*    return(-1.0* (worst + htr)); */

/******************************************************
   HERE
   Objective 1 is now the value of   worst
   Objective 2 is now the value of   htr
   both are doubles 

 For Illustration, both just printed at the moment.
*******************************************************/
    c->o[0] = worst;
    c->o[1] = htr; 
// printf("%g %g\n", worst, htr);


  }


double mmin(double a, double b)
{
 if(a>b) return(b);
 else return(a);
}

double mmax(double a, double b)
{
   if(a>b) return(a);
    else return(b);
 }



double attainmentcut(double * solution, double *control, int curepsize, int dim) {
  
  double dir[dim];
  for (int i=0; i<dim; i++) {
    dir[i] = 1.0;
  }

  // determine minimum distance from attainment surface
  double mind = 0;
  int mini = -1;
  int ctr = 0;

  if (solution[2] >= 1.0 && solution[3] <= 0.0) return 0.0;

  
  // for all points s in the solution front
    for (int i=0; i<curepsize; i++) {
      
      // compute the distance to the closest point c on the control front
      double d = 1.0;
      
      // this is either the distance between s and c
      if (compare_min(&(solution[2]), &(control[i*STEP+2]), 2) == 1) {
      	d = sqrt(square(solution[2]-control[i*STEP+2])+square(solution[3]-control[i*STEP+3]));
      }
      // or the distance to the intersection with the horizontal line through c
      dir[0] = 1.0; dir[1] = 0.0; 
      double d1 = cut(solution, dir, &(control[i*STEP]), dim, control, curepsize);

      // or the distance to the intersection the vertical line through c
      dir[0] = 0.0; dir[1] = 1.0; 
      double d2 = cut(solution, dir, &(control[i*STEP]), dim, control, curepsize);

      // take the minimum 
      d = min(d, min(d1, d2));
  	  
      if ((d != 0) && (d < mind || mini == -1)) {
	mind = d;
	mini = i;
      }
    }
 
  if (mini == -1)  return 0.0;
  return mind;
 
}
 

// compute the intersection between the line through solution with direction dir and the attainment
// surface described by control
double cut(double * solution, double * dir, double * control, int dim, double * others, int curepsize) {

  double oldsum = 0.0;
  double sum = 0.0;
  double lambda = 0.0;
  double ssum = 1.0;


  for (int i=0; i<dim; i++) {
    if (dir[i] == 0) continue;

    lambda = (control[i+2] - solution[i+2]) / dir[i];
    bool valid = true;
    for (int j=0; j<dim; j++) {
      if (i==j) continue;
      if (lambda < 0) {
	valid = false;
	break;

      }
      if (solution[j+2] + lambda*dir[j] < control[j+2]) {
	valid = false;
	break;
      }
    }
    
    if (valid == true) {
       for (int k=0; k<dim; k++) {
	 sum += square(lambda*dir[k]);
       }
	return sqrt(sum);
    }
  }

  return 1.0;
   
}   
  


// Sorts data items in array and (currently) returns the smallest value
double median(double * local_dist, int size) {
   qsort((void *)local_dist, size, sizeof(double), int_lt);
   int index = 0;
   return local_dist[index];
}


int int_lt (const void *a, const void *b) {

 
    if (*(double*)a < *(double*)b)
	return -1;
    if (*(double*)a > *(double*)b)
	return 1;
    
    else return 0;
}



int int_lt1(const void *a, const void *b) {
  double * pta = (double *)a;
  double * ptb = (double *)b;
 
    if (pta[1] < ptb[1])
	return -1;
    if (pta[1] > ptb[1])
	return 1;
    
    else return 0;
}

int int_lt2(const void *a, const void *b) {
  double * pta = (double *)a;
  double * ptb = (double *)b;

    if (pta[2] < ptb[2])
	return -1;
    if (pta[2] > ptb[2])
	return 1;
 
    
    else return 0;
}

